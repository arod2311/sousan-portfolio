Current code on AWS lambda ui:
// index.js - Lambda for DocuSign Connect + Apps Script /send-service-slip
'use strict';

const AWS = require('aws-sdk');
const xml2js = require('xml2js');
const { google } = require('googleapis');
const docusign = require('docusign-esign');
const crypto = require('crypto');

const s3 = new AWS.S3();
const ddb = new AWS.DynamoDB.DocumentClient();
const sns = new AWS.SNS();
const secrets = new AWS.SecretsManager();
const lambdaClient = new AWS.Lambda();
const parser = new xml2js.Parser({ explicitArray: false, trim: true });

/* ===================== ENV ===================== */
const BUCKET = process.env.S3_BUCKET;
const TABLE = process.env.DDB_TABLE;
const SHEET_ID = process.env.SHEET_ID;
const GOOGLE_SECRET_ARN = process.env.GOOGLE_SECRET_ARN;
const SNS_ARN = process.env.SNS_ARN;
const EXPECTED_API_KEY = process.env.API_KEY || '';
const SHEET_NAME = process.env.SHEET_NAME || 'ServiceSlips';

// DocuSign config
const DS_IK = (process.env.DOCUSIGN_INTEGRATION_KEY || '').trim();
const DS_USER_ID = (process.env.DOCUSIGN_USER_ID || '').trim();
const DS_ACCOUNT_ID = (process.env.DOCUSIGN_ACCOUNT_ID || '').trim();
const DS_OAUTH_BASE = ((process.env.DOCUSIGN_OAUTH_BASE_URL || 'account.docusign.com').replace(/^https?:\/\//,'')).trim();
const DS_REST_BASE = (process.env.DOCUSIGN_BASE_PATH || 'https://www.docusign.net/restapi').trim();
const DS_PRIVATE_KEY_SECRET_ARN =
  (process.env.DOCUSIGN_PRIVATE_KEY_SECRET_ARN || process.env.DOCUSIGN_JWT_SECRET_ARN || '').trim();
const DS_TEMPLATE_ID = (process.env.DOCUSIGN_TEMPLATE_ID || '').trim();

// Roles (must match Service Slip template)
const DS_SIGNER_ROLE_ENV    = (process.env.DOCUSIGN_SIGNER_ROLE    || 'SS Delivery Team').trim();
const DS_CC_ROLE_ENV        = (process.env.DOCUSIGN_CC_ROLE        || '').trim();
const DS_APPROVER_ROLE_ENV  = (process.env.DOCUSIGN_APPROVER_ROLE  || 'Staff Approver').trim();
const DS_BILLING_ROLE_ENV   = (process.env.DOCUSIGN_BILLING_ROLE   || 'BillingApproval').trim();

const COUNTER_PK_PREFIX = 'Counter#';

// Signer (driver) + CC defaults
const DEFAULT_SIGNER_EMAIL = (process.env.SERVICE_SLIP_TO_EMAIL || '').trim();
const DEFAULT_SIGNER_NAME  = (process.env.SERVICE_SLIP_TO_NAME_SS_Delivery_Team || 'SS Delivery Team').trim();
const DELIVERY_CC_EMAIL = (process.env.DELIVERY_CC_EMAIL || '').trim();
const DELIVERY_CC_NAME  = (process.env.DELIVERY_CC_NAME  || 'Dispatch Team').trim();

// Staff approver defaults (optional)
const DEFAULT_APPROVER_EMAIL = (process.env.STAFF_APPROVER_EMAIL || '').trim();
const DEFAULT_APPROVER_NAME  = (process.env.STAFF_APPROVER_NAME  || 'Staff Approver').trim();

// Welcome email hook
const SS_SUBJECT_PREFIX = (process.env.SERVICE_SLIP_SUBJECT_PREFIX || 'Service Slip: ').trim();
const WELCOME_LAMBDA_ARN = (process.env.WELCOME_LAMBDA_ARN || '').trim();
const WELCOME_CC = (process.env.WELCOME_CC || '').trim(); // comma-separated
// Behavior toggles
const STORE_CONTRACT_PDF = ['x','on','yes','true','1'].includes(String(process.env.STORE_CONTRACT_PDF ?? 'true').toLowerCase());
const WELCOME_ATTACHMENTS = ['x','on','yes','true','1'].includes(String(process.env.WELCOME_ATTACHMENTS ?? 'false').toLowerCase());
const REQUIRE_ALL_SLIPS_BEFORE_WELCOME = ['x','on','yes','true','1'].includes(String(process.env.REQUIRE_ALL_SLIPS_BEFORE_WELCOME ?? 'true').toLowerCase());

// Contract connect allow-list (contracts only)
const CONTRACT_ALLOWED_TEMPLATE_IDS = (
  process.env.CONTRACT_ALLOWED_TEMPLATE_IDS ||
  '1eda2cbe-0073-4340-9bfe-d3aac29591b7'
).split(',').map(s => s.trim().toLowerCase()).filter(Boolean);

// Role names to identify client/sales in Connect payload (contracts)
const CONTRACT_CLIENT_ROLE = (process.env.CONTRACT_CLIENT_ROLE || 'New Front Load Client').trim();
const CONTRACT_SALES_ROLE  = (process.env.CONTRACT_SALES_ROLE  || 'SS Sales Rep').trim();

/* ===================== UTIL ===================== */
const safeEq  = (a,b) => (a||'').toLowerCase() === (b||'').toLowerCase();
const nonEmpty = s => typeof s === 'string' && s.trim().length > 0;
const onStr = v => ['x','on','yes','true','1'].includes(String(v||'').toLowerCase());
const normHeader = (h) => String(h||'').trim().toLowerCase().replace(/[\s_-]+/g,'');

async function getConnectSecret() {
  if (process.env.CONNECT_HMAC_SECRET) return process.env.CONNECT_HMAC_SECRET;
  if (process.env.CONNECT_HMAC_SECRET_ARN) {
    const sec = await secrets.getSecretValue({ SecretId: process.env.CONNECT_HMAC_SECRET_ARN }).promise();
    const s = sec.SecretString || Buffer.from(sec.SecretBinary || '', 'base64').toString('utf8');
    try { return JSON.parse(s).docusign_connect_hmac || s; } catch { return s; }
  }
  return null;
}

function verifyDocusignHmac(rawBody, headerValue, secret) {
  if (!headerValue || !secret) return false;
  const expected = crypto.createHmac('sha256', Buffer.from(secret, 'utf8'))
                         .update(rawBody, 'utf8')
                         .digest('base64');
  const got = headerValue.replace(/"/g, '');
  try { return crypto.timingSafeEqual(Buffer.from(got), Buffer.from(expected)); }
  catch { return false; }
}

/* ---------- Google Sheets ---------- */
async function getGoogleJwtClient() {
  if (!GOOGLE_SECRET_ARN) throw new Error('GOOGLE_SECRET_ARN not set');
  const sec = await secrets.getSecretValue({ SecretId: GOOGLE_SECRET_ARN }).promise();
  const secretString = sec.SecretString || (sec.SecretBinary && sec.SecretBinary.toString());
  if (!secretString) throw new Error('Google secret returned empty SecretString');
  const serviceAccount = JSON.parse(secretString);
  const jwtClient = new google.auth.JWT(
    serviceAccount.client_email,
    null,
    serviceAccount.private_key,
    ['https://www.googleapis.com/auth/spreadsheets']
  );
  await jwtClient.authorize();
  return jwtClient;
}

function colNumberToLetter(n) {
  let s = '';
  while (n > 0) { const m = (n - 1) % 26; s = String.fromCharCode(65 + m) + s; n = Math.floor((n - 1) / 26); }
  return s;
}

async function appendRowByHeaders(valuesByHeader, targetSheetName = SHEET_NAME) {
  if (!SHEET_ID) throw new Error('SHEET_ID not configured');
  const jwt = await getGoogleJwtClient();
  const sheets = google.sheets({ version: 'v4', auth: jwt });

  const headerResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${targetSheetName}!1:1`
  });
  const sheetHeaders = (headerResp.data && headerResp.data.values && headerResp.data.values[0]) || [];
  const headerCount = Math.max(sheetHeaders.length, Object.keys(valuesByHeader || {}).length, 10);

  const colAResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${targetSheetName}!A:A`
  });
  const colAValues = (colAResp.data && colAResp.data.values) ? colAResp.data.values : [];
  const colAText = [];
  for (let i = 0; i < colAValues.length; i++) {
    const row = colAValues[i];
    colAText.push((row && row.length && typeof row[0] !== 'undefined') ? String(row[0]) : '');
  }
  let firstEmptyRow = null;
  for (let i = 1; i < colAText.length; i++) {
    if (colAText[i] === '' || colAText[i] === null) { firstEmptyRow = i + 1; break; }
  }
  const nextRowIndex = firstEmptyRow ? firstEmptyRow : (colAText.length === 0 ? 2 : colAText.length + 1);

  const row = new Array(headerCount).fill('');
  sheetHeaders.forEach((h, i) => {
    if (!h) return;
    const key = String(h).trim();
    if (Object.prototype.hasOwnProperty.call(valuesByHeader, key)) {
      const val = valuesByHeader[key];
      row[i] = (val === null || typeof val === 'undefined') ? '' :
               (val instanceof Date ? val.toISOString() : String(val));
    }
  });

  const endColIndex = Math.max(sheetHeaders.length, headerCount);
  const lastColLetter = colNumberToLetter(endColIndex);
  const range = `${targetSheetName}!A${nextRowIndex}:${lastColLetter}${nextRowIndex}`;

  await sheets.spreadsheets.values.update({
    spreadsheetId: SHEET_ID, range, valueInputOption: 'RAW', requestBody: { values: [row] }
  });

  console.log(`Wrote ${targetSheetName} row`, nextRowIndex);
  return { rowIndex: nextRowIndex };
}

/* ======= Sheet helper for archiving a completed slip (handles duplicates) ======= */
async function archiveCompletedRowByContract(contractEnvId, extraUpdates = {}) {
  if (!contractEnvId) return false;

  const jwt = await getGoogleJwtClient();
  const sheets = google.sheets({ version: 'v4', auth: jwt });

  const meta = await sheets.spreadsheets.get({
    spreadsheetId: SHEET_ID,
    fields: 'sheets(properties(title,sheetId),protectedRanges)'
  });

  const svcSheet = (meta.data.sheets || []).find(s => s.properties.title === SHEET_NAME);
  if (!svcSheet) { console.warn('ServiceSlips sheet not found'); return false; }
  const svcId = svcSheet.properties.sheetId;

  const headersResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1`
  });
  const headers = (headersResp.data.values && headersResp.data.values[0]) || [];
  const hdrMap = {}; headers.forEach((h,i) => { if (h) hdrMap[String(h).trim()] = i; });

  const ceColIdx = hdrMap['ContractEnvelopeId'];
  if (typeof ceColIdx === 'undefined') { console.warn('ContractEnvelopeId column not found'); return false; }
  const ceLetter = colNumberToLetter(ceColIdx + 1);

  const colResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}`
  });
  const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
  const rowIndexes = [];
  for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) rowIndexes.push(i + 1); }
  if (rowIndexes.length === 0) { console.log('No matching row in sheet for CEID', contractEnvId); return false; }

  const firstRow = rowIndexes[0];
  const rowResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${firstRow}:${firstRow}`
  });
  let values = (rowResp.data.values && rowResp.data.values[0]) || [];

  const apply = (name, val) => { if (typeof hdrMap[name] !== 'undefined') { values[hdrMap[name]] = val; } };
  apply('Status', 'Service Slip Completed');
  apply('UpdatedAt', new Date().toISOString());
  if (extraUpdates.DocS3Key) apply('DocS3Key', extraUpdates.DocS3Key);
  if (extraUpdates.SlipLink)  apply('SlipLink',  extraUpdates.SlipLink);
  if (extraUpdates && typeof extraUpdates === 'object') {
    Object.entries(extraUpdates).forEach(([k, v]) => {
      if (k !== 'DocS3Key' && k !== 'SlipLink') apply(k, v);
    });
  }

  const compSheet = (meta.data.sheets || []).find(s => s.properties.title === 'Completed');
  if (!compSheet) {
    await sheets.spreadsheets.batchUpdate({
      spreadsheetId: SHEET_ID,
      requestBody: { requests: [{ addSheet: { properties: { title: 'Completed' } } }] }
    });
    await sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `Completed!1:1`,
      valueInputOption: 'RAW',
      requestBody: { values: [headers] }
    });
  } else {
    const h = await sheets.spreadsheets.values.get({
      spreadsheetId: SHEET_ID, range: `Completed!1:1`
    });
    const got = (h.data.values && h.data.values[0]) || [];
    if (got.length === 0) {
      await sheets.spreadsheets.values.update({
        spreadsheetId: SHEET_ID,
        range: `Completed!1:1`,
        valueInputOption: 'RAW',
        requestBody: { values: [headers] }
      });
    }
  }

  await sheets.spreadsheets.values.append({
    spreadsheetId: SHEET_ID,
    range: `Completed!A:A`,
    valueInputOption: 'RAW',
    insertDataOption: 'INSERT_ROWS',
    requestBody: { values: [values] }
  });

  async function safeDeleteRow(rowIndex) {
    try {
      await sheets.spreadsheets.batchUpdate({
        spreadsheetId: SHEET_ID,
        requestBody: {
          requests: [{
            deleteDimension: {
              range: { sheetId: svcId, dimension: 'ROWS', startIndex: rowIndex - 1, endIndex: rowIndex }
            }
          }]
        }
      });
      return true;
    } catch (delErr) {
      console.warn('Delete failed; will try removing intersecting protections & retry.', delErr?.message || delErr);
      try {
        const protInThisSheet =
          (meta.data.sheets || []).find(s => s.properties.sheetId === svcId)?.protectedRanges || [];
        const toRemove = protInThisSheet.filter(pr => {
          const r = pr.range || {};
          if (r.sheetId !== svcId) return false;
          const start = (r.startRowIndex ?? 0) + 1;
          const end   = (r.endRowIndex ?? 1e9);
          return rowIndex >= start && rowIndex <= end;
        });
        if (toRemove.length > 0) {
          await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SHEET_ID,
            requestBody: {
              requests: toRemove
                .filter(p => typeof p.protectedRangeId === 'number')
                .map(p => ({ deleteProtectedRange: { protectedRangeId: p.protectedRangeId } }))}
          });
          await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SHEET_ID,
            requestBody: {
              requests: [{
                deleteDimension: {
                  range: { sheetId: svcId, dimension: 'ROWS', startIndex: rowIndex - 1, endIndex: rowIndex }
                }
              }]
            }
          });
          return true;
        }
      } catch (e2) {
        console.warn('Protection removal / retry delete failed:', e2?.message || e2);
      }
      try {
        await sheets.spreadsheets.values.clear({
          spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}`
        });
        await sheets.spreadsheets.values.update({
          spreadsheetId: SHEET_ID,
          range: `${SHEET_NAME}!A${rowIndex}:A${rowIndex}`,
          valueInputOption: 'RAW',
          requestBody: { values: [[`(Archived to Completed @ ${new Date().toISOString()})`]] }
        });
        return true;
      } catch (clrErr) {
        console.error('Fallback clear failed:', clrErr);
        return false;
      }
    }
  }

  rowIndexes.sort((a,b)=>b-a);
  for (let idx = 0; idx < rowIndexes.length; idx++) {
    await safeDeleteRow(rowIndexes[idx]);
  }

  console.log('Archived & removed', rowIndexes.length, 'row(s) for CEID', contractEnvId);
  return true;
}

/* ---------- S3 (named save) ---------- */
function sanitizeForS3(s) {
  return String(s || '')
    .replace(/[^\w\- .]/g, '')
    .replace(/\s+/g,' ')
    .trim();
}
async function savePdfToS3Named({ type, envelopeId, pdfBase64, arCode, clientName }) {
  if (!BUCKET) throw new Error('S3_BUCKET not configured');
  const buffer = Buffer.from(pdfBase64, 'base64');

  const prettyClient = sanitizeForS3(clientName || 'Unknown Customer');
  const prettyAR     = sanitizeForS3(arCode || '');
  const folder = prettyAR ? `${prettyAR} - ${prettyClient}` : `No-AR - ${prettyClient}`;
  const fname  = `${type || 'Document'}-${envelopeId}-${Date.now()}.pdf`;
  const key    = `contracts/${folder}/${sanitizeForS3(fname)}`;

  await s3.putObject({ Bucket: BUCKET, Key: key, Body: buffer, ContentType: 'application/pdf' }).promise();
  const signedUrl = s3.getSignedUrl
    ? s3.getSignedUrl('getObject', { Bucket: BUCKET, Key: key, Expires: 60 * 60 * 24 * 7 })
    : `s3://${BUCKET}/${key}`;
  return { key, signedUrl };
}

/* ---------- API-key gate ---------- */
function checkApiKey(headers) {
  const incomingKey = (headers && (headers['x-api-key'] || headers['X-API-Key'] || headers['X-API-KEY'])) || '';
  if (!incomingKey) return false;
  if (!EXPECTED_API_KEY) { console.warn('No EXPECTED_API_KEY set in Lambda env; rejecting by default'); return false; }
  return incomingKey === EXPECTED_API_KEY;
}

function deriveContractTypeCode(raw) {
  const val = (raw || '').toString().toLowerCase();
  if (val.includes('roll')) return 'RO';
  if (val.includes('ro-')) return 'RO';
  if (val.includes('ro ')) return 'RO';
  if (val.includes('front') || val.includes('fl-') || val.includes('fl ')) return 'FL';
  return val.startsWith('ro') ? 'RO' : 'FL';
}

function normalizeContainerSizeCode(raw) {
  const text = (raw || '').toString().toLowerCase();
  const match = text.match(/(\d{1,3})/);
  if (!match) return '00';
  const num = parseInt(match[1], 10);
  if (!Number.isFinite(num) || num <= 0) return '00';
  return num < 10 ? `0${num}` : String(num);
}

function sanitizeArCode(ar) {
  const cleaned = (ar || '').toString().replace(/[^0-9a-z]/gi, '');
  return cleaned || 'NA';
}

async function nextContainerCounter(prefix, sizeCode) {
  if (!TABLE) throw new Error('DDB_TABLE not configured for container counters');
  const pk = `${COUNTER_PK_PREFIX}${prefix}-${sizeCode}`;
  const res = await ddb.update({
    TableName: TABLE,
    Key: { ContractEnvelopeId: pk },
    UpdateExpression: 'ADD CounterValue :inc',
    ExpressionAttributeValues: { ':inc': 1 },
    ReturnValues: 'UPDATED_NEW'
  }).promise();
  const val = Number(res?.Attributes?.CounterValue || 0);
  if (!Number.isFinite(val) || val <= 0) return 1;
  return val;
}

async function generateContainerId(contractType, containerSize, arCode) {
  const prefix = deriveContractTypeCode(contractType);
  const sizeCode = normalizeContainerSizeCode(containerSize);
  const counterVal = await nextContainerCounter(prefix, sizeCode);
  const counterCode = String(counterVal).padStart(2, '0');
  const arClean = sanitizeArCode(arCode);
  return `${prefix}-${sizeCode}-${counterCode}-${arClean}`;
}

async function ensureContainerIdsForValues(target, context = {}) {
  const result = {};
  if (!target || typeof target !== 'object') return result;
  const contractType = context.contractType || target.ContractType || target.contractType || '';
  const arCode = context.arCode || target.ARNumber || target.ARCode || '';
  const pairs = [
    { sizeKey: 'ContainerSize', idKey: 'ContainerID', qtyKey: 'Quantity', defaultQty: 1 },
    { sizeKey: 'ContainerSize2', idKey: 'ContainerID2', qtyKey: 'Quantity2', defaultQty: 0 },
    { sizeKey: 'ContainerSize3', idKey: 'ContainerID3', qtyKey: 'Quantity3', defaultQty: 0 }
  ];

  for (const { sizeKey, idKey, qtyKey, defaultQty } of pairs) {
    const sizeVal = target[sizeKey] || context[sizeKey];
    const desiredQty = normalizeQty(target[qtyKey], defaultQty);
    const existingList = parseContainerIdList(target[idKey]);
    const needed = Math.max(desiredQty, existingList.length, sizeVal ? 1 : 0);

    if (!needed) {
      if (existingList.length > 0) {
        const joinedExisting = existingList.join('\n');
        target[idKey] = joinedExisting;
        result[idKey] = joinedExisting;
      }
      continue;
    }

    const ids = existingList.slice(0, needed);
    while (ids.length < needed) {
      if (!sizeVal) {
        console.warn('Skipping container id generation - missing size for', sizeKey);
        break;
      }
      try {
        const generated = await generateContainerId(contractType, sizeVal, arCode);
        ids.push(generated);
      } catch (err) {
        console.warn('generateContainerId failed', { sizeKey, sizeVal, message: err?.message || err });
        break;
      }
    }

    if (ids.length > 0) {
      const joined = ids.join('\n');
      target[idKey] = joined;
      result[idKey] = joined;
    }
  }
  return result;
}

function listContainerIdsFromTarget(target) {
  const out = [];
  if (!target || typeof target !== 'object') return out;
  ['ContainerID', 'ContainerID2', 'ContainerID3'].forEach((key) => {
    out.push(...parseContainerIdList(target[key]));
  });
  return out.filter(Boolean);
}

function parseContainerIdList(value) {
  if (!value) return [];
  if (Array.isArray(value)) {
    return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
  }
  return (value || '')
    .toString()
    .split(/[\n,; ]+/)              // FIX: split also on spaces just in case
    .map(s => s.trim())
    .filter(Boolean);
}

function formatBoldLine(label, value) {
  const val = (value ?? '').toString().trim() || '-';
  return `**${label}:** ${val}`;
}

function buildContractSnsMessage(info) {
  if (!info) return '';
  const lines = [
    formatBoldLine('ClientName', info.clientName),
    formatBoldLine('BusinessName', info.businessName),
    formatBoldLine('ServiceAddress', info.serviceAddress),
    formatBoldLine('ARNumber', info.arNumber),
    formatBoldLine('ContractType', info.contractType),
    formatBoldLine('Quantity', info.quantity),
    formatBoldLine('Frequency', info.frequency),
    formatBoldLine('ScheduledPickupDays', info.scheduledPickupDays),
    formatBoldLine('DateSigned', info.dateSigned)
  ];
  if (info.containerId) lines.push(formatBoldLine('ContainerID', info.containerId));
  if (info.envelopeId) lines.push(formatBoldLine('EnvelopeId', info.envelopeId));
  return lines.join('\n');
}

/* ===================== DocuSign helpers ===================== */
async function getDsPrivateKeyPem() {
  if (!DS_PRIVATE_KEY_SECRET_ARN) throw new Error('DOCUSIGN_PRIVATE_KEY_SECRET_ARN not set');
  const sec = await secrets.getSecretValue({ SecretId: DS_PRIVATE_KEY_SECRET_ARN }).promise();
  const secretString = sec.SecretString || (sec.SecretBinary && sec.SecretBinary.toString());
  if (!secretString) throw new Error('DocuSign private key secret empty');
  let possible = secretString;
  try { const obj = JSON.parse(secretString); possible = obj.private_key || obj.privateKey || obj.privateKeyPem || secretString; } catch {}
  return possible;
}

async function getDsApiClient() {
  if (!DS_IK || !DS_USER_ID || !DS_ACCOUNT_ID || !DS_TEMPLATE_ID) {
    throw new Error('Missing DOCUSIGN_* env vars (INTEGRATION_KEY, USER_ID, ACCOUNT_ID, TEMPLATE_ID).');
  }
  const dsClient = new docusign.ApiClient();
  dsClient.setBasePath(DS_REST_BASE);
  dsClient.setOAuthBasePath(DS_OAUTH_BASE);

  const privateKeyPem = await getDsPrivateKeyPem();
  const results = await dsClient.requestJWTUserToken(
    DS_IK, DS_USER_ID, ['signature', 'impersonation'], Buffer.from(privateKeyPem), 3600
  );
  const accessToken = results.body.access_token;
  dsClient.addDefaultHeader('Authorization', 'Bearer ' + accessToken);

  try {
    const ui = await dsClient.getUserInfo(accessToken);
    const acct = ui?.accounts?.find(a => a.accountId === DS_ACCOUNT_ID) || ui?.accounts?.[0];
    if (acct?.baseUri) {
      const resolved = acct.baseUri.endsWith('/restapi') ? acct.baseUri : `${acct.baseUri}/restapi`;
      dsClient.setBasePath(resolved);
      console.log('DocuSign resolved base path from userInfo:', resolved);
    } else {
      console.warn('userInfo returned no accounts/baseUri; using DOCUSIGN_BASE_PATH as-is.');
    }
  } catch (e) {
    console.warn('getUserInfo failed; using DOCUSIGN_BASE_PATH as-is.', e?.message || e);
  }
  return dsClient;
}

/* ---------- Core sender: one Service Slip ---------- */
async function sendServiceSlipWithTemplate(payload) {
  if (!DS_TEMPLATE_ID) throw new Error('DOCUSIGN_TEMPLATE_ID not configured');

  const signerEmail = (payload.DeliveryDriverEmail || payload.DriverEmail || payload.DeliveryEmail || DEFAULT_SIGNER_EMAIL || '').trim();
  const signerName  = (payload.DeliveryDriverName  || payload.AssignedTo  || payload.DeliveryName  || DEFAULT_SIGNER_NAME  || '').trim();
  const slipContainerId = (payload.ContainerID || payload.ContainerNumber || payload.ContainerId || '').toString().trim();
  if (!signerEmail) throw new Error('Driver email not provided (DeliveryDriverEmail/DriverEmail) and SERVICE_SLIP_TO_EMAIL not set');

  const dsClient = await getDsApiClient();
  const envelopesApi = new docusign.EnvelopesApi(dsClient);

  // (best-effort) introspect role names
  try {
    const templatesApi = new docusign.TemplatesApi(dsClient);
    const rec = await templatesApi.listRecipients(DS_ACCOUNT_ID, DS_TEMPLATE_ID);
    const signerRoles = (rec.signers || []).map(s => (s.roleName || '').trim()).filter(nonEmpty);
    const ccRoles     = (rec.carbonCopies || []).map(c => (c.roleName || '').trim()).filter(nonEmpty);
    if (signerRoles.length) {
      if (!signerRoles.some(r => safeEq(r, DS_SIGNER_ROLE_ENV))) {
        console.log('Signer role names on template:', signerRoles);
      }
    }
    if (ccRoles.length && DS_CC_ROLE_ENV && !ccRoles.some(r => safeEq(r, DS_CC_ROLE_ENV))) {
      console.log('CC role names on template:', ccRoles);
    }
  } catch (e) {
    const http = e?.response;
    console.warn('listRecipients failed; proceeding with env role names', {
      status: http?.status, data: http?.data, trace: http?.headers?.['x-docusign-tracetoken']
    });
  }

  const textTabs = [];
  if (payload.ARNumber)        textTabs.push({ tabLabel: 'ARCode', value: String(payload.ARNumber) });
  if (payload.ClientName)      textTabs.push({ tabLabel: 'ClientName', value: String(payload.ClientName) });
  if (payload.ClientEmail)     textTabs.push({ tabLabel: 'ClientEmail', value: String(payload.ClientEmail) });
  if (payload.BusinessName)    textTabs.push({ tabLabel: 'BusinessName', value: String(payload.BusinessName) });
  if (payload.ServiceAddress)  textTabs.push({ tabLabel: 'ServiceAddress', value: String(payload.ServiceAddress) });
  if (payload.BillingAddress)  textTabs.push({ tabLabel: 'BillingAddress', value: String(payload.BillingAddress) });
  if (payload.BillingAddress2) textTabs.push({ tabLabel: 'BillingAddress2', value: String(payload.BillingAddress2) });
  const _ctVal = (function(){
    const ct = (payload.ContractType || '').toString().trim();
    if (ct) return ct;
    const size = (payload.ContainerSize || '').toString().toLowerCase();
    if (/(^|\b)(15yd|20yd|30yd|40yd)(\b|$)/.test(size)) return 'RollOff';
    return 'FrontLoad';
  })();
  ;['ContractType','ClientType','Client Type'].forEach(lbl => textTabs.push({ tabLabel: lbl, value: _ctVal }));
  if (payload.ContactName)     textTabs.push({ tabLabel: 'ContactName', value: String(payload.ContactName) });
  if (payload.ServicePhone)    textTabs.push({ tabLabel: 'ServicePhone', value: String(payload.ServicePhone) });

  const cid = payload.ContainerNumber || payload.ContainerID || payload.ContainerId;
  if (cid) ['ContainerNumber','Container ID #','Container ID','ContainerID'].forEach(lbl =>
    textTabs.push({ tabLabel: lbl, value: String(cid) })
  );

  if (payload.Quantity)      textTabs.push({ tabLabel: 'Quantity', value: String(payload.Quantity) });
  if (payload.ContainerSize) textTabs.push({ tabLabel: 'ContainerSize', value: String(payload.ContainerSize) });
  if (payload.Frequency)     textTabs.push({ tabLabel: 'Frequency', value: String(payload.Frequency) });
  if (payload.ServiceDays)   textTabs.push({ tabLabel: 'ServiceDays', value: String(payload.ServiceDays) });
  if (payload.Notes)         textTabs.push({ tabLabel: 'Notes', value: String(payload.Notes) });
  if (payload.Notes2)        textTabs.push({ tabLabel: 'Notes2', value: String(payload.Notes2) });

  const today = new Date();
  const pad2 = (n) => (n < 10 ? '0' + n : '' + n);
  const mmddyyyy = `${pad2(today.getMonth() + 1)}/${pad2(today.getDate())}/${today.getFullYear()}`;
  const dateTabs = [{ tabLabel: 'Date', value: mmddyyyy }];
  const checkboxTabs = [{ tabLabel: 'Start', selected: 'true' }];

  const sizeIn = (payload.ContainerSize || '').toString().trim().toLowerCase();
  const normSize = sizeIn.replace(/\s|-/g,'').replace(/yard|yds|yrd/g,'yd');
  ['2yd','4yd','6yd','8yd','10yd','15yd','20yd','30yd','40yd'].forEach(lbl => {
    if (normSize === lbl.toLowerCase()) checkboxTabs.push({ tabLabel: lbl, selected: 'true' });
  });

  const freqStr = (payload.Frequency || '').toString().trim();
  const freqN = parseInt(freqStr, 10);
  if (!Number.isNaN(freqN) && freqN >= 1 && freqN <= 6) checkboxTabs.push({ tabLabel: `Freq${freqN}`, selected: 'true' });
  if (/^on[- ]?call$/i.test(freqStr)) checkboxTabs.push({ tabLabel: 'OnCall', selected: 'true' });

  let days = [];
  if (Array.isArray(payload.ServiceDays)) days = payload.ServiceDays;
  else if (typeof payload.ServiceDays === 'string') days = payload.ServiceDays.split(/[,\s]+/).filter(Boolean);
  const mark = (needle, label) => {
    const has = days.map(d => d.toLowerCase()).includes(needle.toLowerCase());
    if (has) checkboxTabs.push({ tabLabel: label, selected: 'true' });
  };
  mark('mon', 'SerD-M'); mark('tue', 'SerD-T'); mark('wed', 'SerD-W');
  mark('thu', 'SerD-Thr'); mark('thur','SerD-Thr'); mark('thurs','SerD-Thr');
  mark('fri', 'SerD-F'); mark('sat', 'SerD-S');

  const tabs = docusign.Tabs.constructFromObject({ textTabs, dateTabs, checkboxTabs });

  const templateRoles = [
    docusign.TemplateRole.constructFromObject({
      roleName: DS_APPROVER_ROLE_ENV, name: (payload.StaffApproverName  || DEFAULT_APPROVER_NAME),
      email: (payload.StaffApproverEmail || DEFAULT_APPROVER_EMAIL), routingOrder: 1, tabs
    }),
    docusign.TemplateRole.constructFromObject({
      roleName: DS_SIGNER_ROLE_ENV, name: signerName || 'SS Delivery Team', email: signerEmail, routingOrder: 2, tabs
    })
  ];
  const billingApprovalEmail = (payload.BillingApprovalEmail || payload.BillingApprovalEmailAddress || '').toString().trim();
  const billingApprovalName  = (payload.BillingApprovalName || '').toString().trim();
  if (billingApprovalEmail) {
    templateRoles.push(
      docusign.TemplateRole.constructFromObject({
        roleName: DS_BILLING_ROLE_ENV,
        name: billingApprovalName || billingApprovalEmail,
        email: billingApprovalEmail,
        routingOrder: 4
      })
    );
  }
  if (DELIVERY_CC_EMAIL && DS_CC_ROLE_ENV) {
    templateRoles.push(
      docusign.TemplateRole.constructFromObject({
        roleName: DS_CC_ROLE_ENV, name: DELIVERY_CC_NAME || 'Dispatch Team', email: DELIVERY_CC_EMAIL
      })
    );
  }

  const envDef = new docusign.EnvelopeDefinition();
  envDef.templateId = DS_TEMPLATE_ID;
  envDef.templateRoles = templateRoles;

  const numbering = (payload.SlipBatchTotal && payload.SlipBatchTotal > 1)
    ? ` [${payload.SlipBatchIndex}/${payload.SlipBatchTotal}]` : '';
  envDef.emailSubject = `${SS_SUBJECT_PREFIX}${payload.ClientName || payload.BusinessName || ''}${numbering}`.trim();
  envDef.customFields = docusign.CustomFields.constructFromObject({
    textCustomFields: [
      { name: 'EnvelopeType', value: 'ServiceSlip', show: 'true' },
      { name: 'ClientEmail',  value: (payload.ClientEmail || '') },
      { name: 'ClientName',   value: (payload.ClientName  || payload.BusinessName || '') },
      { name: 'ContractEnvelopeId', value: (payload.ContractEnvelopeId || '') },
      { name: 'ContractType', value: (function(){
          const ct = (payload.ContractType || '').toString().trim();
          if (ct) return ct;
          const size = (payload.ContainerSize || '').toString().toLowerCase();
          if (/(^|\b)(15yd|20yd|30yd|40yd)(\b|$)/.test(size)) return 'RollOff';
          return 'FrontLoad';
        })() },
      { name: 'SlipBatchId',     value: (payload.SlipBatchId || '') },
      { name: 'SlipBatchIndex',  value: String(payload.SlipBatchIndex || 1) },
      { name: 'SlipBatchTotal',  value: String(payload.SlipBatchTotal || 1) },
      { name: 'ServiceSlipContainerId', value: slipContainerId || '' }
    ]
  });

  envDef.status = 'sent';
  const result = await envelopesApi.createEnvelope(DS_ACCOUNT_ID, { envelopeDefinition: envDef });
  return { envelopeId: result.envelopeId };
}

/* ---------- Multi-line / Multi-quantity expansion ---------- */
function normalizeQty(v, def = 1) {
  const n = parseInt((v ?? '').toString(), 10);
  return Number.isFinite(n) && n > 0 ? n : def;
}
function normStr(v) { return (v ?? '').toString().trim(); }

function expandServiceSlipRequests(base) {
  const lines = [
    {
      qty: normalizeQty(base.Quantity, 1),
      size: normStr(base.ContainerSize),
      freq: normStr(base.Frequency),
      days: normStr(base.ServiceDays),
      ids: parseContainerIdList(base.ContainerID || base.ContainerNumber),
      id: normStr(base.ContainerID || base.ContainerNumber)
    },
    {
      qty: normalizeQty(base.Quantity2, 0),
      size: normStr(base.ContainerSize2),
      freq: normStr(base.Frequency2),
      days: normStr(base.ServiceDays2),
      ids: parseContainerIdList(base.ContainerID2),
      id: normStr(base.ContainerID2)
    },
    {
      qty: normalizeQty(base.Quantity3, 0),
      size: normStr(base.ContainerSize3),
      freq: normStr(base.Frequency3),
      days: normStr(base.ServiceDays3),
      ids: parseContainerIdList(base.ContainerID3),
      id: normStr(base.ContainerID3)
    }
  ];

  const slips = [];
  lines.forEach((ln, idx) => {
    const lineHasData = ln.size || ln.freq || ln.days || ln.id || (ln.ids && ln.ids.length);
    if (!lineHasData && idx > 0) return;
    const qty = ln.qty || (idx === 0 ? 1 : 0);
    if (qty <= 0) return;
    for (let i = 0; i < qty; i++) {
      const p = { ...base };
      p.ContainerSize = ln.size || base.ContainerSize;
      p.Frequency     = ln.freq || base.Frequency;
      p.ServiceDays   = ln.days || base.ServiceDays;
      const idList = ln.ids || [];
      const cid = idList[i] || idList[0] || ln.id;
      if (cid) {
        p.ContainerID = cid;
        p.ContainerNumber = cid;
      }
      slips.push(p);
    }
  });
  return slips;
}

/* ---- Helpers to extract info from Connect ---- */
function extractServiceSlipSummaryFromTabs(tabMap, cfMap = {}) {
  const sizeLabels = ['2yd','4yd','6yd','8yd','10yd','15yd','20yd','30yd','40yd']; // FIX: allow roll-off sizes
  const containerSize = sizeLabels.find(lbl => onStr(tabMap[lbl])) || '';

  let frequency = '';
  for (let i = 1; i <= 6; i++) if (onStr(tabMap[`Freq${i}`])) { frequency = i; break; }
  if (onStr(tabMap['OnCall'])) frequency = 'On-Call';

  const days = [];
  if (onStr(tabMap['SerD-M']))   days.push('Mon');
  if (onStr(tabMap['SerD-T']))   days.push('Tue');
  if (onStr(tabMap['SerD-W']))   days.push('Wed');
  if (onStr(tabMap['SerD-Thr'])) days.push('Thu');
  if (onStr(tabMap['SerD-F']))   days.push('Fri');
  if (onStr(tabMap['SerD-S']))   days.push('Sat');

  const containerId =
    tabMap.ContainerID || tabMap['Container ID #'] || tabMap['Container ID'] || tabMap['ContainerID'] || cfMap.ServiceSlipContainerId || '';

  return {
    containerSize,
    frequency: frequency === '' ? '' : (Number.isFinite(+frequency) ? Number(frequency) : String(frequency)),
    serviceDays: days.join(' '),
    containerId
  };
}

/* ---- NEW: aggregate helpers to collect multi-slip info at the contract item ---- */
async function upsertSlipAgg(contractEnvId, aggItem, s3Key) {
  if (!contractEnvId) return;
  const params = {
    TableName: TABLE,
    Key: { ContractEnvelopeId: contractEnvId },
    UpdateExpression:
      'SET AggSlipItems = list_append(if_not_exists(AggSlipItems, :empty), :one),' +
      '    AggSlipS3Keys = list_append(if_not_exists(AggSlipS3Keys, :empty), :k)',
    ExpressionAttributeValues: {
      ':empty': [],
      ':one': [aggItem || {}],
      ':k': s3Key ? [s3Key] : []
    },
    ReturnValues: 'NONE'
  };
  try { await ddb.update(params).promise(); }
  catch (e) { console.warn('upsertSlipAgg failed', e?.message || e); }
}

async function getSlipAgg(contractEnvId) {
  if (!contractEnvId) return { items: [], keys: [], expected: 0, welcomeSent: false };
  try {
    const r = await ddb.get({ TableName: TABLE, Key: { ContractEnvelopeId: contractEnvId }, ConsistentRead: true }).promise();
    const items = Array.isArray(r?.Item?.AggSlipItems) ? r.Item.AggSlipItems : [];
    const keys  = Array.isArray(r?.Item?.AggSlipS3Keys) ? r.Item.AggSlipS3Keys : [];
    const expected = Number.isFinite(+r?.Item?.AggExpected) ? +r.Item.AggExpected : 0;
    const welcomeSent = !!r?.Item?.WelcomeSent;
    return { items, keys, expected, welcomeSent };
  } catch (e) {
    console.warn('getSlipAgg failed', e?.message || e);
    return { items: [], keys: [], expected: 0, welcomeSent: false };
  }
}

async function getSheetRowMapByContract(contractEnvId) {
  try {
    if (!contractEnvId || !SHEET_ID) return null;
    const jwt = await getGoogleJwtClient();
    const sheets = google.sheets({ version: 'v4', auth: jwt });
    const headersResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1` });
    const headers = (headersResp.data.values && headersResp.data.values[0]) || [];
    const hdrMap = {}; headers.forEach((h,i)=>{ if (h) hdrMap[String(h).trim()] = i; });
    const ceIdx = hdrMap['ContractEnvelopeId'];
    if (typeof ceIdx === 'undefined') return null;
    const ceLetter = colNumberToLetter(ceIdx + 1);
    const colResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}` });
    const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
    let rowIndex = -1; for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) { rowIndex = i + 1; break; } }
    if (rowIndex === -1) return null;
    const rowResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}` });
    const vals = (rowResp.data.values && rowResp.data.values[0]) || [];
    const out = {};
    headers.forEach((h,i)=>{ if (h) out[String(h).trim()] = (typeof vals[i] !== 'undefined') ? vals[i] : ''; });
    return out;
  } catch (e) {
    console.warn('getSheetRowMapByContract failed', e?.message || e);
    return null;
  }
}

async function setSlipExpected(contractEnvId, expectedCount) {
  if (!contractEnvId || !Number.isFinite(+expectedCount) || +expectedCount <= 0) return;
  const params = {
    TableName: TABLE,
    Key: { ContractEnvelopeId: contractEnvId },
    UpdateExpression: 'SET AggExpected = if_not_exists(AggExpected, :n)',
    ExpressionAttributeValues: { ':n': +expectedCount },
    ReturnValues: 'NONE'
  };
  try { await ddb.update(params).promise(); }
  catch (e) { console.warn('setSlipExpected failed', e?.message || e); }
}

function dedupeKeepOrder(arr) {
  const seen = new Set(); const out = [];
  for (const v of arr || []) { if (!v) continue; if (seen.has(v)) continue; seen.add(v); out.push(v); }
  return out;
}

/* ===== FIX: build final rows for email (split multi-ID cells, then fill blanks from agg) ===== */
function expandItemsWithIds(sheetItems, aggItems) {
  const idsFromAgg = (aggItems || [])
    .map(x => x && x.containerId ? String(x.containerId).trim() : '')
    .filter(Boolean);

  let take = 0;
  const out = [];

  (sheetItems || []).forEach(it => {
    const q = Number.isFinite(+it.quantity) ? +it.quantity : 1;
    const base = {
      containerSize: String(it.containerSize || ''),
      frequency:     it.frequency,
      serviceDays:   String(it.serviceDays || '')
    };

    // Important: Split any multi-ID value coming from the sheet.
    const listFromSheet = parseContainerIdList(it.containerId);

    for (let j = 0; j < Math.max(1, q); j++) {
      let cid = (j < listFromSheet.length) ? listFromSheet[j] : '';
      if (!cid && take < idsFromAgg.length) cid = idsFromAgg[take++];
      out.push({ ...base, containerId: cid });
    }
  });

  return out;
}

/* ---- NEW: helpers to read recipients by role ---- */
function collectRecipientsInfo(envInfo) {
  const out = [];
  try {
    const rs = envInfo?.EnvelopeStatus?.RecipientStatuses?.RecipientStatus;
    const arr = Array.isArray(rs) ? rs : (rs ? [rs] : []);
    arr.forEach(r => {
      out.push({
        roleName: (r?.RoleName || r?.roleName || r?.RecipientType || '').toString(),
        userName: (r?.UserName || r?.userName || r?.Name || '').toString(),
        email: (r?.Email || r?.email || '').toString(),
        routingOrder: parseInt((r?.RoutingOrder || r?.routingOrder || '0').toString(), 10) || 0
      });
    });
  } catch (e) {
    console.warn('collectRecipientsInfo failed', e?.message || e);
  }
  return out;
}

async function readContractItemsFromSheet(contractEnvId) {
  try {
    const jwt = await getGoogleJwtClient();
    const sheets = google.sheets({ version: 'v4', auth: jwt });

    const headerResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1` });
    const headers = (headerResp.data.values && headerResp.data.values[0]) || [];
    const hdrIndex = {}; headers.forEach((h,i)=>{ if (h) hdrIndex[normHeader(h)] = i; });

    const findCol = (name) => hdrIndex[normHeader(name)];

    const ceColIdx = findCol('ContractEnvelopeId') ?? findCol('Contract Envelope Id') ?? findCol('EnvelopeId');
    if (typeof ceColIdx === 'undefined') return [];

    const ceLetter = colNumberToLetter(ceColIdx + 1);
    const colResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}` });
    const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
    let rowIndex = -1; for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) { rowIndex = i + 1; break; } }
    if (rowIndex === -1) return [];

    const rowResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}` });
    const vals = (rowResp.data.values && rowResp.data.values[0]) || [];

    function at(h) { const idx = findCol(h); return typeof idx === 'number' ? (vals[idx] ?? '') : ''; }

    const items = [];
    [
      { q: at('Quantity'),  s: at('ContainerSize'),  f: at('Frequency'),  d: at('ServiceDays'),  id: at('ContainerID') },
      { q: at('Quantity2'), s: at('ContainerSize2'), f: at('Frequency2'), d: at('ServiceDays2'), id: at('ContainerID2') },
      { q: at('Quantity3'), s: at('ContainerSize3'), f: at('Frequency3'), d: at('ServiceDays3'), id: at('ContainerID3') }
    ].forEach(l => {
      const has = (l.s || l.f || l.d || l.id);
      if (!has) return;
      const item = {
        containerSize: String(l.s || ''),
        frequency: (l.f !== '' && !isNaN(Number(l.f))) ? Number(l.f) : String(l.f || ''),
        serviceDays: String(l.d || ''),
        containerId: String(l.id || '')
      };
      const q = parseInt(String(l.q || '').trim(), 10);
      if (!isNaN(q) && q > 0) item.quantity = q;
      items.push(item);
    });

    return items;
  } catch (e) {
    console.warn('readContractItemsFromSheet failed', e?.message || e);
    return [];
  }
}

/* ---- Allow check helpers ---- */
function findTemplateIds(info) {
  const ids = new Set();
  (function walk(o) {
    if (!o || typeof o !== 'object') return;
    for (const [k, v] of Object.entries(o)) {
      if (typeof v === 'string' && /templateid/i.test(k) && v.match(/[0-9a-fA-F-]{20,}/)) ids.add(v.toLowerCase());
      if (v && typeof v === 'object') walk(v);
    }
  })(info);
  return [...ids];
}

function contractAllowedCheck(info, cfMap, recipients) {
  const templateIds = findTemplateIds(info);
  const byTemplate  = templateIds.some(id => CONTRACT_ALLOWED_TEMPLATE_IDS.includes(id));
  const envType = (cfMap.EnvelopeType || cfMap['Envelope Type'] || '').toLowerCase();
  const byEnvType   = envType === 'serviceagreements';
  const byRole      = recipients.some(r => safeEq(r.roleName, CONTRACT_CLIENT_ROLE));

  console.log('AllowCheck -> byTemplate:', byTemplate,
              'byEnvType:', byEnvType, 'byRole:', byRole,
              'templateIds:', templateIds, 'envType:', envType);

  return byTemplate || byEnvType || byRole;
}

/* ===================== Handler ===================== */
exports.handler = async (event) => {
  console.log('Event received', {
    routeKey: event.routeKey || (event.httpMethod && (event.httpMethod + ' ' + (event.rawPath || event.path))),
    path: event.rawPath || event.path
  });

  try {
    const headers = event.headers || {};
    const rawBody = event.isBase64Encoded
      ? Buffer.from((event.body || ''), 'base64').toString('utf8')
      : (event.body || '');

    const routeKey = event.routeKey || `${event.httpMethod || 'POST'} ${event.rawPath || event.path || ''}`;
    const isSendSlip =
      (routeKey && /\/send-service-slip\b/.test(routeKey)) ||
      (event.rawPath && /\/send-service-slip\b/.test(event.rawPath || '')) ||
      (event.path && /\/send-service-slip\b/.test(event.path || ''));

    // API key for /send-service-slip
    if (isSendSlip && !checkApiKey(headers)) {
      console.warn('Unauthorized: invalid or missing API key for send-service-slip');
      return { statusCode: 401, body: JSON.stringify({ success: false, error: 'Unauthorized' }) };
    }

    // HMAC for Connect webhooks
    if (!isSendSlip) {
      const sigHeader = headers['x-docusign-signature-1'] || headers['X-DocuSign-Signature-1'];
      const secret = await getConnectSecret();
      if (secret && !verifyDocusignHmac(rawBody, sigHeader, secret)) {
        console.warn('Invalid DocuSign HMAC', { hasHeader: !!sigHeader });
        return { statusCode: 401, body: 'Invalid signature' };
      }
    }

    const contentType = (headers['content-type'] || headers['Content-Type'] || '').toLowerCase();
    console.log('routeKey', routeKey, 'contentType', contentType);

    /* ----------------- Route: send-service-slip ----------------- */
    if (isSendSlip) {
      let payload;
      try { payload = typeof rawBody === 'string' && rawBody.length ? JSON.parse(rawBody) : {}; }
      catch (e) { console.error('Invalid JSON payload', e); return { statusCode: 400, body: JSON.stringify({ success: false, error: 'Invalid JSON body' }) }; }

      // write row
      const valuesByHeader = Object.assign({}, payload);
      valuesByHeader.ARNumber = payload.ARNumber || payload.ARCode || '';
      if (!valuesByHeader.CreatedAt) valuesByHeader.CreatedAt = new Date().toISOString();
      if (!valuesByHeader.Status)     valuesByHeader.Status     = 'Service Slip Initiated';
      if (!valuesByHeader.ServiceRep) valuesByHeader.ServiceRep = 'Pending Assignment';
      const generatedIds = await ensureContainerIdsForValues(valuesByHeader, {
        contractType: payload.ContractType || valuesByHeader.ContractType || '',
        arCode: payload.ARNumber || payload.ARCode || valuesByHeader.ARNumber || ''
      });
      if (generatedIds && Object.keys(generatedIds).length > 0) {
        Object.assign(payload, generatedIds);
      }

      let appended;
      try { appended = await appendRowByHeaders(valuesByHeader, SHEET_NAME); }
      catch (err) {
        console.error('Failed to append from send-service-slip', err);
        return { statusCode: 500, body: JSON.stringify({ success: false, error: 'Failed to write sheet', detail: err.message }) };
      }

      // Expand & send
      try {
        const slips = expandServiceSlipRequests(payload);
        console.log('Prepared slips count:', slips.length, 'details:',
          slips.map((s, idx) => ({
            i: idx + 1,
            size: s.ContainerSize,
            freq: s.Frequency,
            days: s.ServiceDays,
            id: (s.ContainerID || s.ContainerNumber || s.ContainerId || '')
          }))
        );
        if (slips.length === 0) throw new Error('No slip line-items found (check Quantity/ContainerSize/Frequency/ServiceDays fields).');

        const batchId = `${payload.ContractEnvelopeId || 'no-contract'}-${Date.now()}`;
        const envelopeIds = [];

        for (let i = 0; i < slips.length; i++) {
          const one = slips[i];
          one.SlipBatchId = batchId;
          one.SlipBatchIndex = i + 1;
          one.SlipBatchTotal = slips.length;

          console.log(`Sending slip ${i+1}/${slips.length}`, {
            contract: one.ContractEnvelopeId || '(none)',
            size: one.ContainerSize, freq: one.Frequency, days: one.ServiceDays,
            id: (one.ContainerID || one.ContainerNumber || one.ContainerId || '')
          });
          const res = await sendServiceSlipWithTemplate(one);
          envelopeIds.push(res.envelopeId);
        }

        // record expected count
        try { await setSlipExpected(payload.ContractEnvelopeId, slips.length); } catch {}

        return {
          statusCode: 200,
          body: JSON.stringify({
            success: true,
            rowIndex: appended?.rowIndex,
            newStatus: 'Service Slip Initiated',
            serviceSlipEnvelopeId: envelopeIds[0] || null,
            serviceSlipEnvelopeIds: envelopeIds,
            createdCount: envelopeIds.length
          })
        };
      } catch (dsErr) {
        const message = dsErr?.response?.data?.message || dsErr?.message || String(dsErr);
        console.error('DocuSign send failed:', message);
        return {
          statusCode: 200,
          body: JSON.stringify({
            success: true,
            rowIndex: appended?.rowIndex,
            newStatus: 'Service Slip Initiated',
            serviceSlipEnvelopeId: null,
            warning: 'Sheet updated but DocuSign send failed',
            errorDetail: message
          })
        };
      }
    }

    /* ----------------- Route: DocuSign Connect webhook ----------------- */
    let parsed = null;
    try {
      if (contentType.indexOf('xml') !== -1 || (rawBody && rawBody.trim().startsWith('<'))) {
        parsed = await parser.parseStringPromise(rawBody);
      } else {
        parsed = rawBody && rawBody.trim().length ? JSON.parse(rawBody) : {};
      }
    } catch (parseErr) {
      console.warn('XML parse failed, trying JSON fallback:', parseErr.message);
      try { parsed = rawBody && rawBody.trim().length ? JSON.parse(rawBody) : {}; }
      catch (jErr) { console.error('Both XML and JSON parse failed', jErr); return { statusCode: 400, body: 'Invalid payload format' }; }
    }

    const envInfo = (parsed && parsed.DocuSignEnvelopeInformation) ? parsed.DocuSignEnvelopeInformation : parsed;

    const recipients = collectRecipientsInfo(envInfo);

    let envelopeId = null, signerName = null, pdfBase64 = null, statusText = null;
    let isServiceSlip = false, clientEmailCF = '', clientNameCF = '', contractEnvIdCF = '';
    let slipBatchIndex = 1, slipBatchTotal = 1;
    let cfMap = {};

    try {
      if (envInfo?.EnvelopeStatus?.EnvelopeID) envelopeId = envInfo.EnvelopeStatus.EnvelopeID;
      else if (envInfo?.EnvelopeID) envelopeId = envInfo.EnvelopeID;
      else if (envInfo?.envelopeId) envelopeId = envInfo.envelopeId;
      else if (envInfo?.envelopeSummary?.envelopeId) envelopeId = envInfo.envelopeSummary.envelopeId;

      if (envInfo?.EnvelopeStatus?.UserName) signerName = envInfo.EnvelopeStatus.UserName;

      if (envInfo?.EnvelopeStatus?.Status) statusText = envInfo.EnvelopeStatus.Status;
      else if (envInfo?.status) statusText = envInfo.status;

      if (envInfo?.DocumentPDFs?.DocumentPDF) {
        const doc = envInfo.DocumentPDFs.DocumentPDF;
        pdfBase64 = Array.isArray(doc) ? doc[0].PDFBytes : doc.PDFBytes;
      }

      const cfArrays = [];
      if (envInfo?.EnvelopeStatus?.CustomFields?.CustomField) cfArrays.push(envInfo.EnvelopeStatus.CustomFields.CustomField);
      if (envInfo?.CustomFields?.CustomField) cfArrays.push(envInfo.CustomFields.CustomField);
      if (envInfo?.customFields?.textCustomFields) cfArrays.push(envInfo.customFields.textCustomFields);
      if (envInfo?.envelopeSummary?.customFields?.textCustomFields) cfArrays.push(envInfo.envelopeSummary.customFields.textCustomFields);
      const flatCF = []
        .concat(...cfArrays.map(x => Array.isArray(x) ? x : [x]))
        .filter(Boolean)
        .map(x => ({ name: (x.Name || x.name || '').toString(), value: (x.Value || x.value || '').toString() }));
      cfMap = {}; flatCF.forEach(({name, value}) => { if (name) cfMap[name] = value; });
      isServiceSlip = (cfMap.EnvelopeType || '').toLowerCase() === 'serviceslip';
      clientEmailCF = cfMap.ClientEmail || '';
      clientNameCF  = cfMap.ClientName  || '';
      contractEnvIdCF = cfMap.ContractEnvelopeId || '';
      slipBatchIndex = parseInt(cfMap.SlipBatchIndex || '1', 10) || 1;
      slipBatchTotal = parseInt(cfMap.SlipBatchTotal || '1', 10) || 1;
    } catch (err) { console.error('Failed to extract envelope info', err); }

    envelopeId = envelopeId || `env-${Date.now()}`;
    const now = new Date().toISOString();

    function pickTabs(info) {
      const out = {};
      try {
        const rs = info?.EnvelopeStatus?.RecipientStatuses?.RecipientStatus;
        const arr = Array.isArray(rs) ? rs : (rs ? [rs] : []);
        arr.forEach(r => {
          const tabs = r?.TabStatuses?.TabStatus;
          const tArr = Array.isArray(tabs) ? tabs : (tabs ? [tabs] : []);
          tArr.forEach(t => {
            const k = (t.TabLabel || '').toString().trim();
            const v = (t.TabValue || '').toString();
            if (k) out[k] = v;
          });
        });
      } catch {}
      return out;
    }
    const tabMap = pickTabs(envInfo);

    if (!isServiceSlip) {
      const allowed = contractAllowedCheck(envInfo, cfMap, recipients);
      if (!allowed) return { statusCode: 200, body: 'Ignored (not an allowed contract envelope)' };
    }

    const salesRec = recipients.find(r => safeEq(r.roleName, CONTRACT_SALES_ROLE));
    const clientRec = recipients.find(r => safeEq(r.roleName, CONTRACT_CLIENT_ROLE));
    const tabClientName  = (tabMap.ClientName || '').trim();
    const tabClientEmail = (tabMap.ClientEmail || '').trim();

    const clientNameForSave =
      (nonEmpty(tabClientName)  && !safeEq(tabClientName,  salesRec?.userName || '')) ? tabClientName  :
      (nonEmpty(clientNameCF)   && !safeEq(clientNameCF,   salesRec?.userName || '')) ? clientNameCF   :
      (clientRec?.userName || signerName || tabClientName || 'Unknown Customer');

    const clientEmailForSave =
      (nonEmpty(tabClientEmail) && !safeEq(tabClientEmail, salesRec?.email || '')) ? tabClientEmail :
      (nonEmpty(clientEmailCF)) ? clientEmailCF : (clientRec?.email || tabClientEmail || '');

    const arCodeForSave = tabMap.ARCode || tabMap.ARNumber || '';

    let s3Key = null, s3Url = null;
    try {
      if (pdfBase64 && (isServiceSlip || STORE_CONTRACT_PDF)) {
        const s3res = await savePdfToS3Named({
          type: isServiceSlip ? 'ServiceSlip' : 'Contract',
          envelopeId,
          pdfBase64,
          arCode: arCodeForSave,
          clientName: clientNameForSave
        });
        s3Key = s3res.key; s3Url = s3res.signedUrl;
        console.log('Saved PDF to S3 key', s3Key);
      } else if (pdfBase64 && !isServiceSlip) {
        console.log('Config STORE_CONTRACT_PDF=false  skipping contract PDF save');
      } else {
        console.log('No PDF found in payload');
      }
    } catch (err) { console.error('S3 putObject failed', err); }

    const completed = (statusText || '').toLowerCase() === 'completed';
    let contractRowValues = null;

    try {
      const item = {
        ContractEnvelopeId: envelopeId,
        Status: isServiceSlip ? (completed ? 'ServiceSlip Completed' : 'ServiceSlip Update') : (completed ? 'Contract Completed' : 'Contract Signed'),
        CreatedAt: now,
        DocS3Key: s3Key || null,
        SignerName: signerName || clientNameCF || null
      };
      await ddb.put({ TableName: TABLE, Item: item }).promise();
      console.log('Wrote item to DynamoDB:', item);
    } catch (err) { console.error('DynamoDB put failed', err); }

    if (isServiceSlip && completed && contractEnvIdCF) {
      const aggItem = extractServiceSlipSummaryFromTabs(tabMap, cfMap);
      await upsertSlipAgg(contractEnvIdCF, aggItem, s3Key || null);
    }

    if (!isServiceSlip) {
      if (!completed) {
        console.log('Contract not completed yet; skipping sheet append until Completed.');
      } else {
        try {
          const dayStr = (prefix = '') => {
            const val = [];
            const v = k => (tabMap[k] || '').toLowerCase();
            const P = prefix ? (s) => `SerD${prefix}-${s}` : (s) => `SerD-${s}`;
            if (onStr(v(P('M'))))   val.push('Mon');
            if (onStr(v(P('T'))))   val.push('Tue');
            if (onStr(v(P('W'))))   val.push('Wed');
            if (onStr(v(P('Thr')))) val.push('Thu');
            if (onStr(v(P('F'))))   val.push('Fri');
            if (onStr(v(P('S'))))   val.push('Sat');
            return val.join(' ');
          };

          const valuesByHeader = {
            ContractEnvelopeId: envelopeId,
            ClientName: clientNameForSave,
            ClientEmail: clientEmailForSave,
            BusinessName: tabMap.BusinessName || '',
            ServiceAddress: tabMap.ServiceAddress || '',
            BillingAddress: tabMap.BillingAddress || '',
            BillingAddress2: tabMap.BillingAddress2 || '',
            ServiceRep: 'Pending Assignment',
            Status: 'Pending Slip',
            Quantity: tabMap.Quantity || '',
            ContainerSize: tabMap.ContainerSize || '',
            ContainerID: '',
            Frequency: tabMap.Frequency || '',
            ServiceDays: dayStr(''),
            Quantity2: tabMap.Quantity2 || '',
            ContainerSize2: tabMap.ContainerSize2 || '',
            ContainerID2: '',
            Frequency2: tabMap.Frequency2 || '',
            ServiceDays2: dayStr('2'),
            Quantity3: tabMap.Quantity3 || '',
            ContainerSize3: tabMap.ContainerSize3 || '',
            ContainerID3: '',
            Frequency3: tabMap.Frequency3 || '',
            ServiceDays3: dayStr('3'),
            ARNumber: tabMap.ARCode || tabMap.ARNumber || '',
            ContractType: (cfMap.ContractType || '').toString(),
            ContactName: tabMap.ContactName || '',
            ServicePhone: tabMap.ServicePhone || '',
            ServiceChargePerMonth: tabMap.ServiceChargePerMonth || '',
            LandfillCharge: tabMap.LandfillCharge || '',
            ExtraPickUpCharge: tabMap.ExtraPickUpCharge || '',
            FuelSurcharge: tabMap.FuelSurcharge || '',
            DeliveryFee: tabMap.DeliveryFee || '',
            BillingApprovalName: tabMap.BillingApprovalName || '',
            BillingApprovalEmail: tabMap.BillingApprovalEmail || '',
            AssignedTo: '',
            DriverEmail: '',
            DeliveryDriverName: '',
            DeliveryDriverEmail: '',
            ClaimedAt: '',
            CompletedAt: '',
            DocS3Key: s3Key || '',
            CreatedAt: now,
            SlipLink: s3Url || ''
          };

          contractRowValues = valuesByHeader;
          await ensureContainerIdsForValues(valuesByHeader, {
            contractType: valuesByHeader.ContractType || '',
            arCode: valuesByHeader.ARNumber || ''
          });
          const res = await appendRowByHeaders(valuesByHeader, SHEET_NAME);
          console.log('Appended row to Google Sheet for envelope', envelopeId, 'row', res.rowIndex);
        } catch (gsErr) { console.error('Failed to append to Google Sheet:', gsErr); }
      }
    }

    // SNS for contract completion
    try {
      if (!isServiceSlip && SNS_ARN && completed) {
        const quantitySummary = [contractRowValues?.Quantity, contractRowValues?.Quantity2, contractRowValues?.Quantity3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const frequencySummary = [contractRowValues?.Frequency, contractRowValues?.Frequency2, contractRowValues?.Frequency3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const scheduledPickupSummary = [contractRowValues?.ServiceDays, contractRowValues?.ServiceDays2, contractRowValues?.ServiceDays3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const snsMessage = buildContractSnsMessage({
          clientName: clientNameForSave,
          businessName: tabMap.BusinessName || '',
          serviceAddress: tabMap.ServiceAddress || '',
          arNumber: contractRowValues?.ARNumber || arCodeForSave || '',
          contractType: contractRowValues?.ContractType || (cfMap.ContractType || ''),
          quantity: quantitySummary || (contractRowValues?.Quantity ? String(contractRowValues.Quantity).trim() : ''),
          frequency: frequencySummary || (contractRowValues?.Frequency ? String(contractRowValues.Frequency).trim() : ''),
          scheduledPickupDays: scheduledPickupSummary || (contractRowValues?.ServiceDays ? String(contractRowValues.ServiceDays).trim() : ''),
          dateSigned: tabMap.ContartStartDate || tabMap.ContractStartDate || '',
          containerIds: listContainerIdsFromTarget(contractRowValues),
          envelopeId
        });
        await sns.publish({ TopicArn: SNS_ARN, Message: snsMessage, Subject: 'Contract Completed' }).promise();
        console.log('Published SNS message');
      }
    } catch (snsErr) { console.error('SNS publish failed', snsErr); }

    // ===== Service Slip: archive + Welcome =====
    if (isServiceSlip && completed) {
      const isFinalInBatch = (slipBatchTotal <= 1) || (slipBatchIndex === slipBatchTotal);

      // Read aggregation and re-read once after upsert (mitigates one-race on first slip)
      let agg = await getSlipAgg(contractEnvIdCF);
      if (agg.items.length < 1 || agg.expected === 0) {
        await new Promise(r => setTimeout(r, 150)); // tiny backoff
        agg = await getSlipAgg(contractEnvIdCF);
      }
      const allCompleted = !REQUIRE_ALL_SLIPS_BEFORE_WELCOME || (agg.expected > 0 && (agg.items || []).length >= agg.expected);
      const notSentYet = !agg.welcomeSent;

      // FIX: log the welcome gating decision so its obvious in logs
      console.log('Welcome gate', {
        isFinalInBatch, expected: agg.expected, haveItems: (agg.items || []).length, notSentYet
      });

      if (isFinalInBatch && allCompleted && notSentYet) {
        let sheetItems = await readContractItemsFromSheet(contractEnvIdCF);
        if (!sheetItems || sheetItems.length === 0) {
          sheetItems = [ extractServiceSlipSummaryFromTabs(tabMap, cfMap) ];
        }
        // Ensure current slip's ID participates
        const thisSlip = extractServiceSlipSummaryFromTabs(tabMap, cfMap);
        const emailAggItems = Array.isArray(agg.items) ? [...agg.items] : [];
        if (thisSlip && thisSlip.containerId) emailAggItems.push(thisSlip);

        const itemsForEmail = expandItemsWithIds(sheetItems, emailAggItems);
        console.log('Welcome payload items:', {
          sheetItems: sheetItems.length,
          aggItems: (agg.items || []).length,
          finalItems: itemsForEmail.length,
          ids: (agg.items || []).map(x => x && x.containerId).filter(Boolean)
        });

        try {
          const ok = await archiveCompletedRowByContract(
            contractEnvIdCF,
            {
              DocS3Key: s3Key || null,
              SlipLink: s3Url || null,
              ContactName: tabMap.ContactName || '',
              ServicePhone: tabMap.ServicePhone || ''
            }
          );
          if (!ok) console.log('Archive row: nothing to do (row not found).');
        } catch (e) { console.error('Archive row failed:', e?.message || e); }

        let documents = [];
        if (WELCOME_ATTACHMENTS) {
          let contractDoc = null;
          try {
            const getRes = await ddb.get({ TableName: TABLE, Key: { ContractEnvelopeId: contractEnvIdCF } }).promise();
            const k = getRes?.Item?.DocS3Key;
            if (k) contractDoc = { type: 'contract', s3Bucket: BUCKET, s3Key: k, filename: 'Service Agreement.pdf' };
          } catch (e) { console.warn('DDB get for contract failed:', e?.message || e); }

          const slipKeys = dedupeKeepOrder([...(agg.keys || []), s3Key].filter(Boolean));
          slipKeys.forEach((k, i) => {
            documents.push({
              type: 'serviceSlip',
              s3Bucket: BUCKET,
              s3Key: k,
              filename: slipKeys.length > 1 ? `Service Slip ${i+1}.pdf` : 'Service Slip.pdf'
            });
          });
          if (contractDoc) documents.push(contractDoc);
          console.log('Welcome attachments (enabled)', { slipCount: (slipKeys || []).length, hasContract: !!contractDoc });
        } else {
          console.log('Welcome attachments disabled by config');
        }

        if (WELCOME_LAMBDA_ARN) {
          try {
            const payloadToWelcome = {
              event: 'service-slip-completed',
              envelopeId,
              clientEmail: clientEmailForSave || '',
              clientName: clientNameForSave || '',
              businessName: tabMap.BusinessName || '',
              items: itemsForEmail,
              documents,
              ccList: WELCOME_CC ? WELCOME_CC.split(',').map(s => s.trim()).filter(Boolean) : []
            };

            // Idempotency: set WelcomeSent only once
            let canSend = true;
            try {
              await ddb.update({
                TableName: TABLE,
                Key: { ContractEnvelopeId: contractEnvIdCF },
                UpdateExpression: 'SET WelcomeSent = :t',
                ConditionExpression: 'attribute_not_exists(WelcomeSent)',
                ExpressionAttributeValues: { ':t': true }
              }).promise();
            } catch (e) {
              if ((e?.code || e?.name) === 'ConditionalCheckFailedException') {
                canSend = false;
                console.log('Welcome already sent; skipping invoke');
              } else {
                console.warn('WelcomeSent flag update failed; proceeding', e?.message || e);
              }
            }

            if (canSend) {
              await lambdaClient.invoke({
                FunctionName: WELCOME_LAMBDA_ARN,
                InvocationType: 'Event',
                Payload: JSON.stringify(payloadToWelcome)
              }).promise();
              console.log('Invoked Welcome Email Lambda (final, all slips complete)', envelopeId);
            }
          } catch (invErr) { console.error('Welcome Email Lambda invoke failed', invErr); }
        }

        // Staff summary to SNS (built from the Google Sheet row)
        try {
          if (SNS_ARN) {
            const row = await getSheetRowMapByContract(contractEnvIdCF);
            const scheduledDaysParts = [row?.ServiceDays, row?.ServiceDays2, row?.ServiceDays3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const scheduledPickupDays = scheduledDaysParts.length > 0
              ? scheduledDaysParts.join(' | ')
              : (row?.ServiceDays ? String(row.ServiceDays).trim() : '');
            const quantityParts = [row?.Quantity, row?.Quantity2, row?.Quantity3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const frequencyParts = [row?.Frequency, row?.Frequency2, row?.Frequency3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const containerIdsFromRow = listContainerIdsFromTarget(row);

            const snsMessage = buildContractSnsMessage({
              clientName: row?.ClientName || clientNameForSave || '',
              businessName: row?.BusinessName || '',
              serviceAddress: row?.ServiceAddress || '',
              arNumber: row?.ARNumber || '',
              contractType: row?.ContractType || '',
              quantity: quantityParts.join(' | '),
              frequency: frequencyParts.join(' | '),
              scheduledPickupDays,
              dateSigned: row?.ContartStartDate || row?.ContractStartDate || row?.CreatedAt || '',
              containerIds: containerIdsFromRow,
              envelopeId
            });

            await sns.publish({ TopicArn: SNS_ARN, Subject: 'Service Slip Completed - Verify Trux', Message: snsMessage }).promise();
            console.log('Published SNS staff summary');
          }
        } catch (e) { console.error('SNS staff summary failed', e); }
      } else {
        console.log(`Service slip completed (${slipBatchIndex}/${slipBatchTotal})  final-gate not met: isFinal=${isFinalInBatch}, allCompleted=${allCompleted}, notSentYet=${notSentYet}.`);
      }
    }

    return { statusCode: 200, body: 'OK' };
  } catch (err) {
    console.error('Error processing request:', err);
    return { statusCode: 500, body: 'Internal error' };
  }
};


Version 38:
// index.js - Lambda for DocuSign Connect + Apps Script /send-service-slip
'use strict';

const AWS = require('aws-sdk');
const xml2js = require('xml2js');
const { google } = require('googleapis');
const docusign = require('docusign-esign');
const crypto = require('crypto');

const s3 = new AWS.S3();
const ddb = new AWS.DynamoDB.DocumentClient();
const sns = new AWS.SNS();
const secrets = new AWS.SecretsManager();
const lambdaClient = new AWS.Lambda();
const parser = new xml2js.Parser({ explicitArray: false, trim: true });

/* ===================== ENV ===================== */
const BUCKET = process.env.S3_BUCKET;
const TABLE = process.env.DDB_TABLE;
const SHEET_ID = process.env.SHEET_ID;
const GOOGLE_SECRET_ARN = process.env.GOOGLE_SECRET_ARN;
const SNS_ARN = process.env.SNS_ARN;
const EXPECTED_API_KEY = process.env.API_KEY || '';
const SHEET_NAME = process.env.SHEET_NAME || 'ServiceSlips';

// DocuSign config
const DS_IK = (process.env.DOCUSIGN_INTEGRATION_KEY || '').trim();
const DS_USER_ID = (process.env.DOCUSIGN_USER_ID || '').trim();
const DS_ACCOUNT_ID = (process.env.DOCUSIGN_ACCOUNT_ID || '').trim();
const DS_OAUTH_BASE = ((process.env.DOCUSIGN_OAUTH_BASE_URL || 'account.docusign.com').replace(/^https?:\/\//,'')).trim();
const DS_REST_BASE = (process.env.DOCUSIGN_BASE_PATH || 'https://www.docusign.net/restapi').trim();
const DS_PRIVATE_KEY_SECRET_ARN =
  (process.env.DOCUSIGN_PRIVATE_KEY_SECRET_ARN || process.env.DOCUSIGN_JWT_SECRET_ARN || '').trim();
const DS_TEMPLATE_ID = (process.env.DOCUSIGN_TEMPLATE_ID || '').trim();

// Roles (must match Service Slip template)
const DS_SIGNER_ROLE_ENV    = (process.env.DOCUSIGN_SIGNER_ROLE    || 'SS Delivery Team').trim();
const DS_CC_ROLE_ENV        = (process.env.DOCUSIGN_CC_ROLE        || '').trim();
const DS_APPROVER_ROLE_ENV  = (process.env.DOCUSIGN_APPROVER_ROLE  || 'Staff Approver').trim();
const DS_BILLING_ROLE_ENV   = (process.env.DOCUSIGN_BILLING_ROLE   || 'BillingApproval').trim();

const COUNTER_PK_PREFIX = 'Counter#';

// Signer (driver) + CC defaults
const DEFAULT_SIGNER_EMAIL = (process.env.SERVICE_SLIP_TO_EMAIL || '').trim();
const DEFAULT_SIGNER_NAME  = (process.env.SERVICE_SLIP_TO_NAME_SS_Delivery_Team || 'SS Delivery Team').trim();
const DELIVERY_CC_EMAIL = (process.env.DELIVERY_CC_EMAIL || '').trim();
const DELIVERY_CC_NAME  = (process.env.DELIVERY_CC_NAME  || 'Dispatch Team').trim();

// Staff approver defaults (optional)
const DEFAULT_APPROVER_EMAIL = (process.env.STAFF_APPROVER_EMAIL || '').trim();
const DEFAULT_APPROVER_NAME  = (process.env.STAFF_APPROVER_NAME  || 'Staff Approver').trim();

// Welcome email hook
const SS_SUBJECT_PREFIX = (process.env.SERVICE_SLIP_SUBJECT_PREFIX || 'Service Slip: ').trim();
const WELCOME_LAMBDA_ARN = (process.env.WELCOME_LAMBDA_ARN || '').trim();
const WELCOME_CC = (process.env.WELCOME_CC || '').trim(); // comma-separated
// Behavior toggles
const STORE_CONTRACT_PDF = ['x','on','yes','true','1'].includes(String(process.env.STORE_CONTRACT_PDF ?? 'true').toLowerCase());
const WELCOME_ATTACHMENTS = ['x','on','yes','true','1'].includes(String(process.env.WELCOME_ATTACHMENTS ?? 'false').toLowerCase());
const REQUIRE_ALL_SLIPS_BEFORE_WELCOME = ['x','on','yes','true','1'].includes(String(process.env.REQUIRE_ALL_SLIPS_BEFORE_WELCOME ?? 'true').toLowerCase());

// Contract connect allow-list (contracts only)
const CONTRACT_ALLOWED_TEMPLATE_IDS = (
  process.env.CONTRACT_ALLOWED_TEMPLATE_IDS ||
  '1eda2cbe-0073-4340-9bfe-d3aac29591b7'
).split(',').map(s => s.trim().toLowerCase()).filter(Boolean);

// Role names to identify client/sales in Connect payload (contracts)
const CONTRACT_CLIENT_ROLE = (process.env.CONTRACT_CLIENT_ROLE || 'New Front Load Client').trim();
const CONTRACT_SALES_ROLE  = (process.env.CONTRACT_SALES_ROLE  || 'SS Sales Rep').trim();

/* ===================== UTIL ===================== */
const safeEq  = (a,b) => (a||'').toLowerCase() === (b||'').toLowerCase();
const nonEmpty = s => typeof s === 'string' && s.trim().length > 0;
const onStr = v => ['x','on','yes','true','1'].includes(String(v||'').toLowerCase());
const normHeader = (h) => String(h||'').trim().toLowerCase().replace(/[\s_-]+/g,'');

async function getConnectSecret() {
  if (process.env.CONNECT_HMAC_SECRET) return process.env.CONNECT_HMAC_SECRET;
  if (process.env.CONNECT_HMAC_SECRET_ARN) {
    const sec = await secrets.getSecretValue({ SecretId: process.env.CONNECT_HMAC_SECRET_ARN }).promise();
    const s = sec.SecretString || Buffer.from(sec.SecretBinary || '', 'base64').toString('utf8');
    try { return JSON.parse(s).docusign_connect_hmac || s; } catch { return s; }
  }
  return null;
}

function verifyDocusignHmac(rawBody, headerValue, secret) {
  if (!headerValue || !secret) return false;
  const expected = crypto.createHmac('sha256', Buffer.from(secret, 'utf8'))
                         .update(rawBody, 'utf8')
                         .digest('base64');
  const got = headerValue.replace(/"/g, '');
  try { return crypto.timingSafeEqual(Buffer.from(got), Buffer.from(expected)); }
  catch { return false; }
}

/* ---------- Google Sheets ---------- */
async function getGoogleJwtClient() {
  if (!GOOGLE_SECRET_ARN) throw new Error('GOOGLE_SECRET_ARN not set');
  const sec = await secrets.getSecretValue({ SecretId: GOOGLE_SECRET_ARN }).promise();
  const secretString = sec.SecretString || (sec.SecretBinary && sec.SecretBinary.toString());
  if (!secretString) throw new Error('Google secret returned empty SecretString');
  const serviceAccount = JSON.parse(secretString);
  const jwtClient = new google.auth.JWT(
    serviceAccount.client_email,
    null,
    serviceAccount.private_key,
    ['https://www.googleapis.com/auth/spreadsheets']
  );
  await jwtClient.authorize();
  return jwtClient;
}

function colNumberToLetter(n) {
  let s = '';
  while (n > 0) { const m = (n - 1) % 26; s = String.fromCharCode(65 + m) + s; n = Math.floor((n - 1) / 26); }
  return s;
}

async function appendRowByHeaders(valuesByHeader, targetSheetName = SHEET_NAME) {
  if (!SHEET_ID) throw new Error('SHEET_ID not configured');
  const jwt = await getGoogleJwtClient();
  const sheets = google.sheets({ version: 'v4', auth: jwt });

  const headerResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${targetSheetName}!1:1`
  });
  const sheetHeaders = (headerResp.data && headerResp.data.values && headerResp.data.values[0]) || [];
  const headerCount = Math.max(sheetHeaders.length, Object.keys(valuesByHeader || {}).length, 10);

  const colAResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${targetSheetName}!A:A`
  });
  const colAValues = (colAResp.data && colAResp.data.values) ? colAResp.data.values : [];
  const colAText = [];
  for (let i = 0; i < colAValues.length; i++) {
    const row = colAValues[i];
    colAText.push((row && row.length && typeof row[0] !== 'undefined') ? String(row[0]) : '');
  }
  let firstEmptyRow = null;
  for (let i = 1; i < colAText.length; i++) {
    if (colAText[i] === '' || colAText[i] === null) { firstEmptyRow = i + 1; break; }
  }
  const nextRowIndex = firstEmptyRow ? firstEmptyRow : (colAText.length === 0 ? 2 : colAText.length + 1);

  const row = new Array(headerCount).fill('');
  sheetHeaders.forEach((h, i) => {
    if (!h) return;
    const key = String(h).trim();
    if (Object.prototype.hasOwnProperty.call(valuesByHeader, key)) {
      const val = valuesByHeader[key];
      row[i] = (val === null || typeof val === 'undefined') ? '' :
               (val instanceof Date ? val.toISOString() : String(val));
    }
  });

  const endColIndex = Math.max(sheetHeaders.length, headerCount);
  const lastColLetter = colNumberToLetter(endColIndex);
  const range = `${targetSheetName}!A${nextRowIndex}:${lastColLetter}${nextRowIndex}`;

  await sheets.spreadsheets.values.update({
    spreadsheetId: SHEET_ID, range, valueInputOption: 'RAW', requestBody: { values: [row] }
  });

  console.log(`Wrote ${targetSheetName} row`, nextRowIndex);
  return { rowIndex: nextRowIndex };
}

/* ======= Sheet helper for archiving a completed slip (handles duplicates) ======= */
async function archiveCompletedRowByContract(contractEnvId, extraUpdates = {}) {
  if (!contractEnvId) return false;

  const jwt = await getGoogleJwtClient();
  const sheets = google.sheets({ version: 'v4', auth: jwt });

  const meta = await sheets.spreadsheets.get({
    spreadsheetId: SHEET_ID,
    fields: 'sheets(properties(title,sheetId),protectedRanges)'
  });

  const svcSheet = (meta.data.sheets || []).find(s => s.properties.title === SHEET_NAME);
  if (!svcSheet) { console.warn('ServiceSlips sheet not found'); return false; }
  const svcId = svcSheet.properties.sheetId;

  const headersResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1`
  });
  const headers = (headersResp.data.values && headersResp.data.values[0]) || [];
  const hdrMap = {}; headers.forEach((h,i) => { if (h) hdrMap[String(h).trim()] = i; });

  const ceColIdx = hdrMap['ContractEnvelopeId'];
  if (typeof ceColIdx === 'undefined') { console.warn('ContractEnvelopeId column not found'); return false; }
  const ceLetter = colNumberToLetter(ceColIdx + 1);

  const colResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}`
  });
  const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
  const rowIndexes = [];
  for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) rowIndexes.push(i + 1); }
  if (rowIndexes.length === 0) { console.log('No matching row in sheet for CEID', contractEnvId); return false; }

  const firstRow = rowIndexes[0];
  const rowResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${firstRow}:${firstRow}`
  });
  let values = (rowResp.data.values && rowResp.data.values[0]) || [];

  const apply = (name, val) => { if (typeof hdrMap[name] !== 'undefined') { values[hdrMap[name]] = val; } };
  apply('Status', 'Service Slip Completed');
  apply('UpdatedAt', new Date().toISOString());
  if (extraUpdates.DocS3Key) apply('DocS3Key', extraUpdates.DocS3Key);
  if (extraUpdates.SlipLink)  apply('SlipLink',  extraUpdates.SlipLink);
  if (extraUpdates && typeof extraUpdates === 'object') {
    Object.entries(extraUpdates).forEach(([k, v]) => {
      if (k !== 'DocS3Key' && k !== 'SlipLink') apply(k, v);
    });
  }

  const compSheet = (meta.data.sheets || []).find(s => s.properties.title === 'Completed');
  if (!compSheet) {
    await sheets.spreadsheets.batchUpdate({
      spreadsheetId: SHEET_ID,
      requestBody: { requests: [{ addSheet: { properties: { title: 'Completed' } } }] }
    });
    await sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `Completed!1:1`,
      valueInputOption: 'RAW',
      requestBody: { values: [headers] }
    });
  } else {
    const h = await sheets.spreadsheets.values.get({
      spreadsheetId: SHEET_ID, range: `Completed!1:1`
    });
    const got = (h.data.values && h.data.values[0]) || [];
    if (got.length === 0) {
      await sheets.spreadsheets.values.update({
        spreadsheetId: SHEET_ID,
        range: `Completed!1:1`,
        valueInputOption: 'RAW',
        requestBody: { values: [headers] }
      });
    }
  }

  await sheets.spreadsheets.values.append({
    spreadsheetId: SHEET_ID,
    range: `Completed!A:A`,
    valueInputOption: 'RAW',
    insertDataOption: 'INSERT_ROWS',
    requestBody: { values: [values] }
  });

  async function safeDeleteRow(rowIndex) {
    try {
      await sheets.spreadsheets.batchUpdate({
        spreadsheetId: SHEET_ID,
        requestBody: {
          requests: [{
            deleteDimension: {
              range: { sheetId: svcId, dimension: 'ROWS', startIndex: rowIndex - 1, endIndex: rowIndex }
            }
          }]
        }
      });
      return true;
    } catch (delErr) {
      console.warn('Delete failed; will try removing intersecting protections & retry.', delErr?.message || delErr);
      try {
        const protInThisSheet =
          (meta.data.sheets || []).find(s => s.properties.sheetId === svcId)?.protectedRanges || [];
        const toRemove = protInThisSheet.filter(pr => {
          const r = pr.range || {};
          if (r.sheetId !== svcId) return false;
          const start = (r.startRowIndex ?? 0) + 1;
          const end   = (r.endRowIndex ?? 1e9);
          return rowIndex >= start && rowIndex <= end;
        });
        if (toRemove.length > 0) {
          await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SHEET_ID,
            requestBody: {
              requests: toRemove
                .filter(p => typeof p.protectedRangeId === 'number')
                .map(p => ({ deleteProtectedRange: { protectedRangeId: p.protectedRangeId } }))}
          });
          await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SHEET_ID,
            requestBody: {
              requests: [{
                deleteDimension: {
                  range: { sheetId: svcId, dimension: 'ROWS', startIndex: rowIndex - 1, endIndex: rowIndex }
                }
              }]
            }
          });
          return true;
        }
      } catch (e2) {
        console.warn('Protection removal / retry delete failed:', e2?.message || e2);
      }
      try {
        await sheets.spreadsheets.values.clear({
          spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}`
        });
        await sheets.spreadsheets.values.update({
          spreadsheetId: SHEET_ID,
          range: `${SHEET_NAME}!A${rowIndex}:A${rowIndex}`,
          valueInputOption: 'RAW',
          requestBody: { values: [[`(Archived to Completed @ ${new Date().toISOString()})`]] }
        });
        return true;
      } catch (clrErr) {
        console.error('Fallback clear failed:', clrErr);
        return false;
      }
    }
  }

  rowIndexes.sort((a,b)=>b-a);
  for (let idx = 0; idx < rowIndexes.length; idx++) {
    await safeDeleteRow(rowIndexes[idx]);
  }

  console.log('Archived & removed', rowIndexes.length, 'row(s) for CEID', contractEnvId);
  return true;
}

/* ---------- S3 (named save) ---------- */
function sanitizeForS3(s) {
  return String(s || '')
    .replace(/[^\w\- .]/g, '')
    .replace(/\s+/g,' ')
    .trim();
}
async function savePdfToS3Named({ type, envelopeId, pdfBase64, arCode, clientName }) {
  if (!BUCKET) throw new Error('S3_BUCKET not configured');
  const buffer = Buffer.from(pdfBase64, 'base64');

  const prettyClient = sanitizeForS3(clientName || 'Unknown Customer');
  const prettyAR     = sanitizeForS3(arCode || '');
  const folder = prettyAR ? `${prettyAR} - ${prettyClient}` : `No-AR - ${prettyClient}`;
  const fname  = `${type || 'Document'}-${envelopeId}-${Date.now()}.pdf`;
  const key    = `contracts/${folder}/${sanitizeForS3(fname)}`;

  await s3.putObject({ Bucket: BUCKET, Key: key, Body: buffer, ContentType: 'application/pdf' }).promise();
  const signedUrl = s3.getSignedUrl
    ? s3.getSignedUrl('getObject', { Bucket: BUCKET, Key: key, Expires: 60 * 60 * 24 * 7 })
    : `s3://${BUCKET}/${key}`;
  return { key, signedUrl };
}

/* ---------- API-key gate ---------- */
function checkApiKey(headers) {
  const incomingKey = (headers && (headers['x-api-key'] || headers['X-API-Key'] || headers['X-API-KEY'])) || '';
  if (!incomingKey) return false;
  if (!EXPECTED_API_KEY) { console.warn('No EXPECTED_API_KEY set in Lambda env; rejecting by default'); return false; }
  return incomingKey === EXPECTED_API_KEY;
}

function deriveContractTypeCode(raw) {
  const val = (raw || '').toString().toLowerCase();
  if (val.includes('roll')) return 'RO';
  if (val.includes('ro-')) return 'RO';
  if (val.includes('ro ')) return 'RO';
  if (val.includes('front') || val.includes('fl-') || val.includes('fl ')) return 'FL';
  return val.startsWith('ro') ? 'RO' : 'FL';
}

function normalizeContainerSizeCode(raw) {
  const text = (raw || '').toString().toLowerCase();
  const match = text.match(/(\d{1,3})/);
  if (!match) return '00';
  const num = parseInt(match[1], 10);
  if (!Number.isFinite(num) || num <= 0) return '00';
  return num < 10 ? `0${num}` : String(num);
}

function sanitizeArCode(ar) {
  const cleaned = (ar || '').toString().replace(/[^0-9a-z]/gi, '');
  return cleaned || 'NA';
}

async function nextContainerCounter(prefix, sizeCode) {
  if (!TABLE) throw new Error('DDB_TABLE not configured for container counters');
  const pk = `${COUNTER_PK_PREFIX}${prefix}-${sizeCode}`;
  const res = await ddb.update({
    TableName: TABLE,
    Key: { ContractEnvelopeId: pk },
    UpdateExpression: 'ADD CounterValue :inc',
    ExpressionAttributeValues: { ':inc': 1 },
    ReturnValues: 'UPDATED_NEW'
  }).promise();
  const val = Number(res?.Attributes?.CounterValue || 0);
  if (!Number.isFinite(val) || val <= 0) return 1;
  return val;
}

async function generateContainerId(contractType, containerSize, arCode) {
  const prefix = deriveContractTypeCode(contractType);
  const sizeCode = normalizeContainerSizeCode(containerSize);
  const counterVal = await nextContainerCounter(prefix, sizeCode);
  const counterCode = String(counterVal).padStart(2, '0');
  const arClean = sanitizeArCode(arCode);
  return `${prefix}-${sizeCode}-${counterCode}-${arClean}`;
}

async function ensureContainerIdsForValues(target, context = {}) {
  const result = {};
  if (!target || typeof target !== 'object') return result;
  const contractType = context.contractType || target.ContractType || target.contractType || '';
  const arCode = context.arCode || target.ARNumber || target.ARCode || '';
  const pairs = [
    { sizeKey: 'ContainerSize', idKey: 'ContainerID', qtyKey: 'Quantity', defaultQty: 1 },
    { sizeKey: 'ContainerSize2', idKey: 'ContainerID2', qtyKey: 'Quantity2', defaultQty: 0 },
    { sizeKey: 'ContainerSize3', idKey: 'ContainerID3', qtyKey: 'Quantity3', defaultQty: 0 }
  ];

  for (const { sizeKey, idKey, qtyKey, defaultQty } of pairs) {
    const sizeVal = target[sizeKey] || context[sizeKey];
    const desiredQty = normalizeQty(target[qtyKey], defaultQty);
    const existingList = parseContainerIdList(target[idKey]);
    const needed = Math.max(desiredQty, existingList.length, sizeVal ? 1 : 0);

    if (!needed) {
      if (existingList.length > 0) {
        const joinedExisting = existingList.join('\n');
        target[idKey] = joinedExisting;
        result[idKey] = joinedExisting;
      }
      continue;
    }

    const ids = existingList.slice(0, needed);
    while (ids.length < needed) {
      if (!sizeVal) {
        console.warn('Skipping container id generation - missing size for', sizeKey);
        break;
      }
      try {
        const generated = await generateContainerId(contractType, sizeVal, arCode);
        ids.push(generated);
      } catch (err) {
        console.warn('generateContainerId failed', { sizeKey, sizeVal, message: err?.message || err });
        break;
      }
    }

    if (ids.length > 0) {
      const joined = ids.join('\n');
      target[idKey] = joined;
      result[idKey] = joined;
    }
  }
  return result;
}

function listContainerIdsFromTarget(target) {
  const out = [];
  if (!target || typeof target !== 'object') return out;
  ['ContainerID', 'ContainerID2', 'ContainerID3'].forEach((key) => {
    out.push(...parseContainerIdList(target[key]));
  });
  return out.filter(Boolean);
}

function parseContainerIdList(value) {
  if (!value) return [];
  if (Array.isArray(value)) {
    return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
  }
  return (value || '')
    .toString()
    .split(/[\n,; ]+/)              // FIX: split also on spaces just in case
    .map(s => s.trim())
    .filter(Boolean);
}

function formatBoldLine(label, value) {
  const val = (value ?? '').toString().trim() || '-';
  return `**${label}:** ${val}`;
}

function buildContractSnsMessage(info) {
  if (!info) return '';
  const lines = [
    formatBoldLine('ClientName', info.clientName),
    formatBoldLine('BusinessName', info.businessName),
    formatBoldLine('ServiceAddress', info.serviceAddress),
    formatBoldLine('ARNumber', info.arNumber),
    formatBoldLine('ContractType', info.contractType),
    formatBoldLine('Quantity', info.quantity),
    formatBoldLine('Frequency', info.frequency),
    formatBoldLine('ScheduledPickupDays', info.scheduledPickupDays),
    formatBoldLine('DateSigned', info.dateSigned)
  ];
  if (info.containerId) lines.push(formatBoldLine('ContainerID', info.containerId));
  if (info.envelopeId) lines.push(formatBoldLine('EnvelopeId', info.envelopeId));
  return lines.join('\n');
}

/* ===================== DocuSign helpers ===================== */
async function getDsPrivateKeyPem() {
  if (!DS_PRIVATE_KEY_SECRET_ARN) throw new Error('DOCUSIGN_PRIVATE_KEY_SECRET_ARN not set');
  const sec = await secrets.getSecretValue({ SecretId: DS_PRIVATE_KEY_SECRET_ARN }).promise();
  const secretString = sec.SecretString || (sec.SecretBinary && sec.SecretBinary.toString());
  if (!secretString) throw new Error('DocuSign private key secret empty');
  let possible = secretString;
  try { const obj = JSON.parse(secretString); possible = obj.private_key || obj.privateKey || obj.privateKeyPem || secretString; } catch {}
  return possible;
}

async function getDsApiClient() {
  if (!DS_IK || !DS_USER_ID || !DS_ACCOUNT_ID || !DS_TEMPLATE_ID) {
    throw new Error('Missing DOCUSIGN_* env vars (INTEGRATION_KEY, USER_ID, ACCOUNT_ID, TEMPLATE_ID).');
  }
  const dsClient = new docusign.ApiClient();
  dsClient.setBasePath(DS_REST_BASE);
  dsClient.setOAuthBasePath(DS_OAUTH_BASE);

  const privateKeyPem = await getDsPrivateKeyPem();
  const results = await dsClient.requestJWTUserToken(
    DS_IK, DS_USER_ID, ['signature', 'impersonation'], Buffer.from(privateKeyPem), 3600
  );
  const accessToken = results.body.access_token;
  dsClient.addDefaultHeader('Authorization', 'Bearer ' + accessToken);

  try {
    const ui = await dsClient.getUserInfo(accessToken);
    const acct = ui?.accounts?.find(a => a.accountId === DS_ACCOUNT_ID) || ui?.accounts?.[0];
    if (acct?.baseUri) {
      const resolved = acct.baseUri.endsWith('/restapi') ? acct.baseUri : `${acct.baseUri}/restapi`;
      dsClient.setBasePath(resolved);
      console.log('DocuSign resolved base path from userInfo:', resolved);
    } else {
      console.warn('userInfo returned no accounts/baseUri; using DOCUSIGN_BASE_PATH as-is.');
    }
  } catch (e) {
    console.warn('getUserInfo failed; using DOCUSIGN_BASE_PATH as-is.', e?.message || e);
  }
  return dsClient;
}

/* ---------- Core sender: one Service Slip ---------- */
async function sendServiceSlipWithTemplate(payload) {
  if (!DS_TEMPLATE_ID) throw new Error('DOCUSIGN_TEMPLATE_ID not configured');

  const signerEmail = (payload.DeliveryDriverEmail || payload.DriverEmail || payload.DeliveryEmail || DEFAULT_SIGNER_EMAIL || '').trim();
  const signerName  = (payload.DeliveryDriverName  || payload.AssignedTo  || payload.DeliveryName  || DEFAULT_SIGNER_NAME  || '').trim();
  const slipContainerId = (payload.ContainerID || payload.ContainerNumber || payload.ContainerId || '').toString().trim();
  if (!signerEmail) throw new Error('Driver email not provided (DeliveryDriverEmail/DriverEmail) and SERVICE_SLIP_TO_EMAIL not set');

  const dsClient = await getDsApiClient();
  const envelopesApi = new docusign.EnvelopesApi(dsClient);

  // (best-effort) introspect role names
  try {
    const templatesApi = new docusign.TemplatesApi(dsClient);
    const rec = await templatesApi.listRecipients(DS_ACCOUNT_ID, DS_TEMPLATE_ID);
    const signerRoles = (rec.signers || []).map(s => (s.roleName || '').trim()).filter(nonEmpty);
    const ccRoles     = (rec.carbonCopies || []).map(c => (c.roleName || '').trim()).filter(nonEmpty);
    if (signerRoles.length) {
      if (!signerRoles.some(r => safeEq(r, DS_SIGNER_ROLE_ENV))) {
        console.log('Signer role names on template:', signerRoles);
      }
    }
    if (ccRoles.length && DS_CC_ROLE_ENV && !ccRoles.some(r => safeEq(r, DS_CC_ROLE_ENV))) {
      console.log('CC role names on template:', ccRoles);
    }
  } catch (e) {
    const http = e?.response;
    console.warn('listRecipients failed; proceeding with env role names', {
      status: http?.status, data: http?.data, trace: http?.headers?.['x-docusign-tracetoken']
    });
  }

  const textTabs = [];
  if (payload.ARNumber)        textTabs.push({ tabLabel: 'ARCode', value: String(payload.ARNumber) });
  if (payload.ClientName)      textTabs.push({ tabLabel: 'ClientName', value: String(payload.ClientName) });
  if (payload.ClientEmail)     textTabs.push({ tabLabel: 'ClientEmail', value: String(payload.ClientEmail) });
  if (payload.BusinessName)    textTabs.push({ tabLabel: 'BusinessName', value: String(payload.BusinessName) });
  if (payload.ServiceAddress)  textTabs.push({ tabLabel: 'ServiceAddress', value: String(payload.ServiceAddress) });
  if (payload.BillingAddress)  textTabs.push({ tabLabel: 'BillingAddress', value: String(payload.BillingAddress) });
  if (payload.BillingAddress2) textTabs.push({ tabLabel: 'BillingAddress2', value: String(payload.BillingAddress2) });
  const _ctVal = (function(){
    const ct = (payload.ContractType || '').toString().trim();
    if (ct) return ct;
    const size = (payload.ContainerSize || '').toString().toLowerCase();
    if (/(^|\b)(15yd|20yd|30yd|40yd)(\b|$)/.test(size)) return 'RollOff';
    return 'FrontLoad';
  })();
  ;['ContractType','ClientType','Client Type'].forEach(lbl => textTabs.push({ tabLabel: lbl, value: _ctVal }));
  if (payload.ContactName)     textTabs.push({ tabLabel: 'ContactName', value: String(payload.ContactName) });
  if (payload.ServicePhone)    textTabs.push({ tabLabel: 'ServicePhone', value: String(payload.ServicePhone) });

  const cid = payload.ContainerNumber || payload.ContainerID || payload.ContainerId;
  if (cid) ['ContainerNumber','Container ID #','Container ID','ContainerID'].forEach(lbl =>
    textTabs.push({ tabLabel: lbl, value: String(cid) })
  );

  if (payload.Quantity)      textTabs.push({ tabLabel: 'Quantity', value: String(payload.Quantity) });
  if (payload.ContainerSize) textTabs.push({ tabLabel: 'ContainerSize', value: String(payload.ContainerSize) });
  if (payload.Frequency)     textTabs.push({ tabLabel: 'Frequency', value: String(payload.Frequency) });
  if (payload.ServiceDays)   textTabs.push({ tabLabel: 'ServiceDays', value: String(payload.ServiceDays) });
  if (payload.Notes)         textTabs.push({ tabLabel: 'Notes', value: String(payload.Notes) });
  if (payload.Notes2)        textTabs.push({ tabLabel: 'Notes2', value: String(payload.Notes2) });

  const today = new Date();
  const pad2 = (n) => (n < 10 ? '0' + n : '' + n);
  const mmddyyyy = `${pad2(today.getMonth() + 1)}/${pad2(today.getDate())}/${today.getFullYear()}`;
  const dateTabs = [{ tabLabel: 'Date', value: mmddyyyy }];
  const checkboxTabs = [{ tabLabel: 'Start', selected: 'true' }];

  const sizeIn = (payload.ContainerSize || '').toString().trim().toLowerCase();
  const normSize = sizeIn.replace(/\s|-/g,'').replace(/yard|yds|yrd/g,'yd');
  ['2yd','4yd','6yd','8yd','10yd','15yd','20yd','30yd','40yd'].forEach(lbl => {
    if (normSize === lbl.toLowerCase()) checkboxTabs.push({ tabLabel: lbl, selected: 'true' });
  });

  const freqStr = (payload.Frequency || '').toString().trim();
  const freqN = parseInt(freqStr, 10);
  if (!Number.isNaN(freqN) && freqN >= 1 && freqN <= 6) checkboxTabs.push({ tabLabel: `Freq${freqN}`, selected: 'true' });
  if (/^on[- ]?call$/i.test(freqStr)) checkboxTabs.push({ tabLabel: 'OnCall', selected: 'true' });

  let days = [];
  if (Array.isArray(payload.ServiceDays)) days = payload.ServiceDays;
  else if (typeof payload.ServiceDays === 'string') days = payload.ServiceDays.split(/[,\s]+/).filter(Boolean);
  const mark = (needle, label) => {
    const has = days.map(d => d.toLowerCase()).includes(needle.toLowerCase());
    if (has) checkboxTabs.push({ tabLabel: label, selected: 'true' });
  };
  mark('mon', 'SerD-M'); mark('tue', 'SerD-T'); mark('wed', 'SerD-W');
  mark('thu', 'SerD-Thr'); mark('thur','SerD-Thr'); mark('thurs','SerD-Thr');
  mark('fri', 'SerD-F'); mark('sat', 'SerD-S');

  const tabs = docusign.Tabs.constructFromObject({ textTabs, dateTabs, checkboxTabs });

  const templateRoles = [
    docusign.TemplateRole.constructFromObject({
      roleName: DS_APPROVER_ROLE_ENV, name: (payload.StaffApproverName  || DEFAULT_APPROVER_NAME),
      email: (payload.StaffApproverEmail || DEFAULT_APPROVER_EMAIL), routingOrder: 1, tabs
    }),
    docusign.TemplateRole.constructFromObject({
      roleName: DS_SIGNER_ROLE_ENV, name: signerName || 'SS Delivery Team', email: signerEmail, routingOrder: 2, tabs
    })
  ];
  const billingApprovalEmail = (payload.BillingApprovalEmail || payload.BillingApprovalEmailAddress || '').toString().trim();
  const billingApprovalName  = (payload.BillingApprovalName || '').toString().trim();
  if (billingApprovalEmail) {
    templateRoles.push(
      docusign.TemplateRole.constructFromObject({
        roleName: DS_BILLING_ROLE_ENV,
        name: billingApprovalName || billingApprovalEmail,
        email: billingApprovalEmail,
        routingOrder: 4
      })
    );
  }
  if (DELIVERY_CC_EMAIL && DS_CC_ROLE_ENV) {
    templateRoles.push(
      docusign.TemplateRole.constructFromObject({
        roleName: DS_CC_ROLE_ENV, name: DELIVERY_CC_NAME || 'Dispatch Team', email: DELIVERY_CC_EMAIL
      })
    );
  }

  const envDef = new docusign.EnvelopeDefinition();
  envDef.templateId = DS_TEMPLATE_ID;
  envDef.templateRoles = templateRoles;

  const numbering = (payload.SlipBatchTotal && payload.SlipBatchTotal > 1)
    ? ` [${payload.SlipBatchIndex}/${payload.SlipBatchTotal}]` : '';
  envDef.emailSubject = `${SS_SUBJECT_PREFIX}${payload.ClientName || payload.BusinessName || ''}${numbering}`.trim();
  envDef.customFields = docusign.CustomFields.constructFromObject({
    textCustomFields: [
      { name: 'EnvelopeType', value: 'ServiceSlip', show: 'true' },
      { name: 'ClientEmail',  value: (payload.ClientEmail || '') },
      { name: 'ClientName',   value: (payload.ClientName  || payload.BusinessName || '') },
      { name: 'ContractEnvelopeId', value: (payload.ContractEnvelopeId || '') },
      { name: 'ContractType', value: (function(){
          const ct = (payload.ContractType || '').toString().trim();
          if (ct) return ct;
          const size = (payload.ContainerSize || '').toString().toLowerCase();
          if (/(^|\b)(15yd|20yd|30yd|40yd)(\b|$)/.test(size)) return 'RollOff';
          return 'FrontLoad';
        })() },
      { name: 'SlipBatchId',     value: (payload.SlipBatchId || '') },
      { name: 'SlipBatchIndex',  value: String(payload.SlipBatchIndex || 1) },
      { name: 'SlipBatchTotal',  value: String(payload.SlipBatchTotal || 1) },
      { name: 'ServiceSlipContainerId', value: slipContainerId || '' }
    ]
  });

  envDef.status = 'sent';
  const result = await envelopesApi.createEnvelope(DS_ACCOUNT_ID, { envelopeDefinition: envDef });
  return { envelopeId: result.envelopeId };
}

/* ---------- Multi-line / Multi-quantity expansion ---------- */
function normalizeQty(v, def = 1) {
  const n = parseInt((v ?? '').toString(), 10);
  return Number.isFinite(n) && n > 0 ? n : def;
}
function normStr(v) { return (v ?? '').toString().trim(); }

function expandServiceSlipRequests(base) {
  const lines = [
    {
      qty: normalizeQty(base.Quantity, 1),
      size: normStr(base.ContainerSize),
      freq: normStr(base.Frequency),
      days: normStr(base.ServiceDays),
      ids: parseContainerIdList(base.ContainerID || base.ContainerNumber),
      id: normStr(base.ContainerID || base.ContainerNumber)
    },
    {
      qty: normalizeQty(base.Quantity2, 0),
      size: normStr(base.ContainerSize2),
      freq: normStr(base.Frequency2),
      days: normStr(base.ServiceDays2),
      ids: parseContainerIdList(base.ContainerID2),
      id: normStr(base.ContainerID2)
    },
    {
      qty: normalizeQty(base.Quantity3, 0),
      size: normStr(base.ContainerSize3),
      freq: normStr(base.Frequency3),
      days: normStr(base.ServiceDays3),
      ids: parseContainerIdList(base.ContainerID3),
      id: normStr(base.ContainerID3)
    }
  ];

  const slips = [];
  lines.forEach((ln, idx) => {
    const lineHasData = ln.size || ln.freq || ln.days || ln.id || (ln.ids && ln.ids.length);
    if (!lineHasData && idx > 0) return;
    const qty = ln.qty || (idx === 0 ? 1 : 0);
    if (qty <= 0) return;
    for (let i = 0; i < qty; i++) {
      const p = { ...base };
      p.ContainerSize = ln.size || base.ContainerSize;
      p.Frequency     = ln.freq || base.Frequency;
      p.ServiceDays   = ln.days || base.ServiceDays;
      const idList = ln.ids || [];
      const cid = idList[i] || idList[0] || ln.id;
      if (cid) {
        p.ContainerID = cid;
        p.ContainerNumber = cid;
      }
      slips.push(p);
    }
  });
  return slips;
}

/* ---- Helpers to extract info from Connect ---- */
function extractServiceSlipSummaryFromTabs(tabMap, cfMap = {}) {
  const sizeLabels = ['2yd','4yd','6yd','8yd','10yd','15yd','20yd','30yd','40yd']; // FIX: allow roll-off sizes
  const containerSize = sizeLabels.find(lbl => onStr(tabMap[lbl])) || '';

  let frequency = '';
  for (let i = 1; i <= 6; i++) if (onStr(tabMap[`Freq${i}`])) { frequency = i; break; }
  if (onStr(tabMap['OnCall'])) frequency = 'On-Call';

  const days = [];
  if (onStr(tabMap['SerD-M']))   days.push('Mon');
  if (onStr(tabMap['SerD-T']))   days.push('Tue');
  if (onStr(tabMap['SerD-W']))   days.push('Wed');
  if (onStr(tabMap['SerD-Thr'])) days.push('Thu');
  if (onStr(tabMap['SerD-F']))   days.push('Fri');
  if (onStr(tabMap['SerD-S']))   days.push('Sat');

  const containerId =
    tabMap.ContainerID || tabMap['Container ID #'] || tabMap['Container ID'] || tabMap['ContainerID'] || cfMap.ServiceSlipContainerId || '';

  return {
    containerSize,
    frequency: frequency === '' ? '' : (Number.isFinite(+frequency) ? Number(frequency) : String(frequency)),
    serviceDays: days.join(' '),
    containerId
  };
}

/* ---- NEW: aggregate helpers to collect multi-slip info at the contract item ---- */
async function upsertSlipAgg(contractEnvId, aggItem, s3Key) {
  if (!contractEnvId) return;
  const params = {
    TableName: TABLE,
    Key: { ContractEnvelopeId: contractEnvId },
    UpdateExpression:
      'SET AggSlipItems = list_append(if_not_exists(AggSlipItems, :empty), :one),' +
      '    AggSlipS3Keys = list_append(if_not_exists(AggSlipS3Keys, :empty), :k)',
    ExpressionAttributeValues: {
      ':empty': [],
      ':one': [aggItem || {}],
      ':k': s3Key ? [s3Key] : []
    },
    ReturnValues: 'NONE'
  };
  try { await ddb.update(params).promise(); }
  catch (e) { console.warn('upsertSlipAgg failed', e?.message || e); }
}

async function getSlipAgg(contractEnvId) {
  if (!contractEnvId) return { items: [], keys: [], expected: 0, welcomeSent: false };
  try {
    const r = await ddb.get({ TableName: TABLE, Key: { ContractEnvelopeId: contractEnvId }, ConsistentRead: true }).promise();
    const items = Array.isArray(r?.Item?.AggSlipItems) ? r.Item.AggSlipItems : [];
    const keys  = Array.isArray(r?.Item?.AggSlipS3Keys) ? r.Item.AggSlipS3Keys : [];
    const expected = Number.isFinite(+r?.Item?.AggExpected) ? +r.Item.AggExpected : 0;
    const welcomeSent = !!r?.Item?.WelcomeSent;
    return { items, keys, expected, welcomeSent };
  } catch (e) {
    console.warn('getSlipAgg failed', e?.message || e);
    return { items: [], keys: [], expected: 0, welcomeSent: false };
  }
}

async function getSheetRowMapByContract(contractEnvId) {
  try {
    if (!contractEnvId || !SHEET_ID) return null;
    const jwt = await getGoogleJwtClient();
    const sheets = google.sheets({ version: 'v4', auth: jwt });
    const headersResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1` });
    const headers = (headersResp.data.values && headersResp.data.values[0]) || [];
    const hdrMap = {}; headers.forEach((h,i)=>{ if (h) hdrMap[String(h).trim()] = i; });
    const ceIdx = hdrMap['ContractEnvelopeId'];
    if (typeof ceIdx === 'undefined') return null;
    const ceLetter = colNumberToLetter(ceIdx + 1);
    const colResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}` });
    const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
    let rowIndex = -1; for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) { rowIndex = i + 1; break; } }
    if (rowIndex === -1) return null;
    const rowResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}` });
    const vals = (rowResp.data.values && rowResp.data.values[0]) || [];
    const out = {};
    headers.forEach((h,i)=>{ if (h) out[String(h).trim()] = (typeof vals[i] !== 'undefined') ? vals[i] : ''; });
    return out;
  } catch (e) {
    console.warn('getSheetRowMapByContract failed', e?.message || e);
    return null;
  }
}

async function setSlipExpected(contractEnvId, expectedCount) {
  if (!contractEnvId || !Number.isFinite(+expectedCount) || +expectedCount <= 0) return;
  const params = {
    TableName: TABLE,
    Key: { ContractEnvelopeId: contractEnvId },
    UpdateExpression: 'SET AggExpected = if_not_exists(AggExpected, :n)',
    ExpressionAttributeValues: { ':n': +expectedCount },
    ReturnValues: 'NONE'
  };
  try { await ddb.update(params).promise(); }
  catch (e) { console.warn('setSlipExpected failed', e?.message || e); }
}

function dedupeKeepOrder(arr) {
  const seen = new Set(); const out = [];
  for (const v of arr || []) { if (!v) continue; if (seen.has(v)) continue; seen.add(v); out.push(v); }
  return out;
}

/* ===== FIX: build final rows for email (split multi-ID cells, then fill blanks from agg) ===== */
function expandItemsWithIds(sheetItems, aggItems) {
  const idsFromAgg = (aggItems || [])
    .map(x => x && x.containerId ? String(x.containerId).trim() : '')
    .filter(Boolean);

  let take = 0;
  const out = [];

  (sheetItems || []).forEach(it => {
    const q = Number.isFinite(+it.quantity) ? +it.quantity : 1;
    const base = {
      containerSize: String(it.containerSize || ''),
      frequency:     it.frequency,
      serviceDays:   String(it.serviceDays || '')
    };

    // Important: Split any multi-ID value coming from the sheet.
    const listFromSheet = parseContainerIdList(it.containerId);

    for (let j = 0; j < Math.max(1, q); j++) {
      let cid = (j < listFromSheet.length) ? listFromSheet[j] : '';
      if (!cid && take < idsFromAgg.length) cid = idsFromAgg[take++];
      out.push({ ...base, containerId: cid });
    }
  });

  return out;
}

/* ---- NEW: helpers to read recipients by role ---- */
function collectRecipientsInfo(envInfo) {
  const out = [];
  try {
    const rs = envInfo?.EnvelopeStatus?.RecipientStatuses?.RecipientStatus;
    const arr = Array.isArray(rs) ? rs : (rs ? [rs] : []);
    arr.forEach(r => {
      out.push({
        roleName: (r?.RoleName || r?.roleName || r?.RecipientType || '').toString(),
        userName: (r?.UserName || r?.userName || r?.Name || '').toString(),
        email: (r?.Email || r?.email || '').toString(),
        routingOrder: parseInt((r?.RoutingOrder || r?.routingOrder || '0').toString(), 10) || 0
      });
    });
  } catch (e) {
    console.warn('collectRecipientsInfo failed', e?.message || e);
  }
  return out;
}

async function readContractItemsFromSheet(contractEnvId) {
  try {
    const jwt = await getGoogleJwtClient();
    const sheets = google.sheets({ version: 'v4', auth: jwt });

    const headerResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1` });
    const headers = (headerResp.data.values && headerResp.data.values[0]) || [];
    const hdrIndex = {}; headers.forEach((h,i)=>{ if (h) hdrIndex[normHeader(h)] = i; });

    const findCol = (name) => hdrIndex[normHeader(name)];

    const ceColIdx = findCol('ContractEnvelopeId') ?? findCol('Contract Envelope Id') ?? findCol('EnvelopeId');
    if (typeof ceColIdx === 'undefined') return [];

    const ceLetter = colNumberToLetter(ceColIdx + 1);
    const colResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}` });
    const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
    let rowIndex = -1; for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) { rowIndex = i + 1; break; } }
    if (rowIndex === -1) return [];

    const rowResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}` });
    const vals = (rowResp.data.values && rowResp.data.values[0]) || [];

    function at(h) { const idx = findCol(h); return typeof idx === 'number' ? (vals[idx] ?? '') : ''; }

    const items = [];
    [
      { q: at('Quantity'),  s: at('ContainerSize'),  f: at('Frequency'),  d: at('ServiceDays'),  id: at('ContainerID') },
      { q: at('Quantity2'), s: at('ContainerSize2'), f: at('Frequency2'), d: at('ServiceDays2'), id: at('ContainerID2') },
      { q: at('Quantity3'), s: at('ContainerSize3'), f: at('Frequency3'), d: at('ServiceDays3'), id: at('ContainerID3') }
    ].forEach(l => {
      const has = (l.s || l.f || l.d || l.id);
      if (!has) return;
      const item = {
        containerSize: String(l.s || ''),
        frequency: (l.f !== '' && !isNaN(Number(l.f))) ? Number(l.f) : String(l.f || ''),
        serviceDays: String(l.d || ''),
        containerId: String(l.id || '')
      };
      const q = parseInt(String(l.q || '').trim(), 10);
      if (!isNaN(q) && q > 0) item.quantity = q;
      items.push(item);
    });

    return items;
  } catch (e) {
    console.warn('readContractItemsFromSheet failed', e?.message || e);
    return [];
  }
}

/* ---- Allow check helpers ---- */
function findTemplateIds(info) {
  const ids = new Set();
  (function walk(o) {
    if (!o || typeof o !== 'object') return;
    for (const [k, v] of Object.entries(o)) {
      if (typeof v === 'string' && /templateid/i.test(k) && v.match(/[0-9a-fA-F-]{20,}/)) ids.add(v.toLowerCase());
      if (v && typeof v === 'object') walk(v);
    }
  })(info);
  return [...ids];
}

function contractAllowedCheck(info, cfMap, recipients) {
  const templateIds = findTemplateIds(info);
  const byTemplate  = templateIds.some(id => CONTRACT_ALLOWED_TEMPLATE_IDS.includes(id));
  const envType = (cfMap.EnvelopeType || cfMap['Envelope Type'] || '').toLowerCase();
  const byEnvType   = envType === 'serviceagreements';
  const byRole      = recipients.some(r => safeEq(r.roleName, CONTRACT_CLIENT_ROLE));

  console.log('AllowCheck -> byTemplate:', byTemplate,
              'byEnvType:', byEnvType, 'byRole:', byRole,
              'templateIds:', templateIds, 'envType:', envType);

  return byTemplate || byEnvType || byRole;
}

/* ===================== Handler ===================== */
exports.handler = async (event) => {
  console.log('Event received', {
    routeKey: event.routeKey || (event.httpMethod && (event.httpMethod + ' ' + (event.rawPath || event.path))),
    path: event.rawPath || event.path
  });

  try {
    const headers = event.headers || {};
    const rawBody = event.isBase64Encoded
      ? Buffer.from((event.body || ''), 'base64').toString('utf8')
      : (event.body || '');

    const routeKey = event.routeKey || `${event.httpMethod || 'POST'} ${event.rawPath || event.path || ''}`;
    const isSendSlip =
      (routeKey && /\/send-service-slip\b/.test(routeKey)) ||
      (event.rawPath && /\/send-service-slip\b/.test(event.rawPath || '')) ||
      (event.path && /\/send-service-slip\b/.test(event.path || ''));

    // API key for /send-service-slip
    if (isSendSlip && !checkApiKey(headers)) {
      console.warn('Unauthorized: invalid or missing API key for send-service-slip');
      return { statusCode: 401, body: JSON.stringify({ success: false, error: 'Unauthorized' }) };
    }

    // HMAC for Connect webhooks
    if (!isSendSlip) {
      const sigHeader = headers['x-docusign-signature-1'] || headers['X-DocuSign-Signature-1'];
      const secret = await getConnectSecret();
      if (secret && !verifyDocusignHmac(rawBody, sigHeader, secret)) {
        console.warn('Invalid DocuSign HMAC', { hasHeader: !!sigHeader });
        return { statusCode: 401, body: 'Invalid signature' };
      }
    }

    const contentType = (headers['content-type'] || headers['Content-Type'] || '').toLowerCase();
    console.log('routeKey', routeKey, 'contentType', contentType);

    /* ----------------- Route: send-service-slip ----------------- */
    if (isSendSlip) {
      let payload;
      try { payload = typeof rawBody === 'string' && rawBody.length ? JSON.parse(rawBody) : {}; }
      catch (e) { console.error('Invalid JSON payload', e); return { statusCode: 400, body: JSON.stringify({ success: false, error: 'Invalid JSON body' }) }; }

      // write row
      const valuesByHeader = Object.assign({}, payload);
      valuesByHeader.ARNumber = payload.ARNumber || payload.ARCode || '';
      if (!valuesByHeader.CreatedAt) valuesByHeader.CreatedAt = new Date().toISOString();
      if (!valuesByHeader.Status)     valuesByHeader.Status     = 'Service Slip Initiated';
      if (!valuesByHeader.ServiceRep) valuesByHeader.ServiceRep = 'Pending Assignment';
      const generatedIds = await ensureContainerIdsForValues(valuesByHeader, {
        contractType: payload.ContractType || valuesByHeader.ContractType || '',
        arCode: payload.ARNumber || payload.ARCode || valuesByHeader.ARNumber || ''
      });
      if (generatedIds && Object.keys(generatedIds).length > 0) {
        Object.assign(payload, generatedIds);
      }

      let appended;
      try { appended = await appendRowByHeaders(valuesByHeader, SHEET_NAME); }
      catch (err) {
        console.error('Failed to append from send-service-slip', err);
        return { statusCode: 500, body: JSON.stringify({ success: false, error: 'Failed to write sheet', detail: err.message }) };
      }

      // Expand & send
      try {
        const slips = expandServiceSlipRequests(payload);
        console.log('Prepared slips count:', slips.length, 'details:',
          slips.map((s, idx) => ({
            i: idx + 1,
            size: s.ContainerSize,
            freq: s.Frequency,
            days: s.ServiceDays,
            id: (s.ContainerID || s.ContainerNumber || s.ContainerId || '')
          }))
        );
        if (slips.length === 0) throw new Error('No slip line-items found (check Quantity/ContainerSize/Frequency/ServiceDays fields).');

        const batchId = `${payload.ContractEnvelopeId || 'no-contract'}-${Date.now()}`;
        const envelopeIds = [];

        for (let i = 0; i < slips.length; i++) {
          const one = slips[i];
          one.SlipBatchId = batchId;
          one.SlipBatchIndex = i + 1;
          one.SlipBatchTotal = slips.length;

          console.log(`Sending slip ${i+1}/${slips.length}`, {
            contract: one.ContractEnvelopeId || '(none)',
            size: one.ContainerSize, freq: one.Frequency, days: one.ServiceDays,
            id: (one.ContainerID || one.ContainerNumber || one.ContainerId || '')
          });
          const res = await sendServiceSlipWithTemplate(one);
          envelopeIds.push(res.envelopeId);
        }

        // record expected count
        try { await setSlipExpected(payload.ContractEnvelopeId, slips.length); } catch {}

        return {
          statusCode: 200,
          body: JSON.stringify({
            success: true,
            rowIndex: appended?.rowIndex,
            newStatus: 'Service Slip Initiated',
            serviceSlipEnvelopeId: envelopeIds[0] || null,
            serviceSlipEnvelopeIds: envelopeIds,
            createdCount: envelopeIds.length
          })
        };
      } catch (dsErr) {
        const message = dsErr?.response?.data?.message || dsErr?.message || String(dsErr);
        console.error('DocuSign send failed:', message);
        return {
          statusCode: 200,
          body: JSON.stringify({
            success: true,
            rowIndex: appended?.rowIndex,
            newStatus: 'Service Slip Initiated',
            serviceSlipEnvelopeId: null,
            warning: 'Sheet updated but DocuSign send failed',
            errorDetail: message
          })
        };
      }
    }

    /* ----------------- Route: DocuSign Connect webhook ----------------- */
    let parsed = null;
    try {
      if (contentType.indexOf('xml') !== -1 || (rawBody && rawBody.trim().startsWith('<'))) {
        parsed = await parser.parseStringPromise(rawBody);
      } else {
        parsed = rawBody && rawBody.trim().length ? JSON.parse(rawBody) : {};
      }
    } catch (parseErr) {
      console.warn('XML parse failed, trying JSON fallback:', parseErr.message);
      try { parsed = rawBody && rawBody.trim().length ? JSON.parse(rawBody) : {}; }
      catch (jErr) { console.error('Both XML and JSON parse failed', jErr); return { statusCode: 400, body: 'Invalid payload format' }; }
    }

    const envInfo = (parsed && parsed.DocuSignEnvelopeInformation) ? parsed.DocuSignEnvelopeInformation : parsed;

    const recipients = collectRecipientsInfo(envInfo);

    let envelopeId = null, signerName = null, pdfBase64 = null, statusText = null;
    let isServiceSlip = false, clientEmailCF = '', clientNameCF = '', contractEnvIdCF = '';
    let slipBatchIndex = 1, slipBatchTotal = 1;
    let cfMap = {};

    try {
      if (envInfo?.EnvelopeStatus?.EnvelopeID) envelopeId = envInfo.EnvelopeStatus.EnvelopeID;
      else if (envInfo?.EnvelopeID) envelopeId = envInfo.EnvelopeID;
      else if (envInfo?.envelopeId) envelopeId = envInfo.envelopeId;
      else if (envInfo?.envelopeSummary?.envelopeId) envelopeId = envInfo.envelopeSummary.envelopeId;

      if (envInfo?.EnvelopeStatus?.UserName) signerName = envInfo.EnvelopeStatus.UserName;

      if (envInfo?.EnvelopeStatus?.Status) statusText = envInfo.EnvelopeStatus.Status;
      else if (envInfo?.status) statusText = envInfo.status;

      if (envInfo?.DocumentPDFs?.DocumentPDF) {
        const doc = envInfo.DocumentPDFs.DocumentPDF;
        pdfBase64 = Array.isArray(doc) ? doc[0].PDFBytes : doc.PDFBytes;
      }

      const cfArrays = [];
      if (envInfo?.EnvelopeStatus?.CustomFields?.CustomField) cfArrays.push(envInfo.EnvelopeStatus.CustomFields.CustomField);
      if (envInfo?.CustomFields?.CustomField) cfArrays.push(envInfo.CustomFields.CustomField);
      if (envInfo?.customFields?.textCustomFields) cfArrays.push(envInfo.customFields.textCustomFields);
      if (envInfo?.envelopeSummary?.customFields?.textCustomFields) cfArrays.push(envInfo.envelopeSummary.customFields.textCustomFields);
      const flatCF = []
        .concat(...cfArrays.map(x => Array.isArray(x) ? x : [x]))
        .filter(Boolean)
        .map(x => ({ name: (x.Name || x.name || '').toString(), value: (x.Value || x.value || '').toString() }));
      cfMap = {}; flatCF.forEach(({name, value}) => { if (name) cfMap[name] = value; });
      isServiceSlip = (cfMap.EnvelopeType || '').toLowerCase() === 'serviceslip';
      clientEmailCF = cfMap.ClientEmail || '';
      clientNameCF  = cfMap.ClientName  || '';
      contractEnvIdCF = cfMap.ContractEnvelopeId || '';
      slipBatchIndex = parseInt(cfMap.SlipBatchIndex || '1', 10) || 1;
      slipBatchTotal = parseInt(cfMap.SlipBatchTotal || '1', 10) || 1;
    } catch (err) { console.error('Failed to extract envelope info', err); }

    envelopeId = envelopeId || `env-${Date.now()}`;
    const now = new Date().toISOString();

    function pickTabs(info) {
      const out = {};
      try {
        const rs = info?.EnvelopeStatus?.RecipientStatuses?.RecipientStatus;
        const arr = Array.isArray(rs) ? rs : (rs ? [rs] : []);
        arr.forEach(r => {
          const tabs = r?.TabStatuses?.TabStatus;
          const tArr = Array.isArray(tabs) ? tabs : (tabs ? [tabs] : []);
          tArr.forEach(t => {
            const k = (t.TabLabel || '').toString().trim();
            const v = (t.TabValue || '').toString();
            if (k) out[k] = v;
          });
        });
      } catch {}
      return out;
    }
    const tabMap = pickTabs(envInfo);

    if (!isServiceSlip) {
      const allowed = contractAllowedCheck(envInfo, cfMap, recipients);
      if (!allowed) return { statusCode: 200, body: 'Ignored (not an allowed contract envelope)' };
    }

    const salesRec = recipients.find(r => safeEq(r.roleName, CONTRACT_SALES_ROLE));
    const clientRec = recipients.find(r => safeEq(r.roleName, CONTRACT_CLIENT_ROLE));
    const tabClientName  = (tabMap.ClientName || '').trim();
    const tabClientEmail = (tabMap.ClientEmail || '').trim();

    const clientNameForSave =
      (nonEmpty(tabClientName)  && !safeEq(tabClientName,  salesRec?.userName || '')) ? tabClientName  :
      (nonEmpty(clientNameCF)   && !safeEq(clientNameCF,   salesRec?.userName || '')) ? clientNameCF   :
      (clientRec?.userName || signerName || tabClientName || 'Unknown Customer');

    const clientEmailForSave =
      (nonEmpty(tabClientEmail) && !safeEq(tabClientEmail, salesRec?.email || '')) ? tabClientEmail :
      (nonEmpty(clientEmailCF)) ? clientEmailCF : (clientRec?.email || tabClientEmail || '');

    const arCodeForSave = tabMap.ARCode || tabMap.ARNumber || '';

    let s3Key = null, s3Url = null;
    try {
      if (pdfBase64 && (isServiceSlip || STORE_CONTRACT_PDF)) {
        const s3res = await savePdfToS3Named({
          type: isServiceSlip ? 'ServiceSlip' : 'Contract',
          envelopeId,
          pdfBase64,
          arCode: arCodeForSave,
          clientName: clientNameForSave
        });
        s3Key = s3res.key; s3Url = s3res.signedUrl;
        console.log('Saved PDF to S3 key', s3Key);
      } else if (pdfBase64 && !isServiceSlip) {
        console.log('Config STORE_CONTRACT_PDF=false  skipping contract PDF save');
      } else {
        console.log('No PDF found in payload');
      }
    } catch (err) { console.error('S3 putObject failed', err); }

    const completed = (statusText || '').toLowerCase() === 'completed';
    let contractRowValues = null;

    try {
      const item = {
        ContractEnvelopeId: envelopeId,
        Status: isServiceSlip ? (completed ? 'ServiceSlip Completed' : 'ServiceSlip Update') : (completed ? 'Contract Completed' : 'Contract Signed'),
        CreatedAt: now,
        DocS3Key: s3Key || null,
        SignerName: signerName || clientNameCF || null
      };
      await ddb.put({ TableName: TABLE, Item: item }).promise();
      console.log('Wrote item to DynamoDB:', item);
    } catch (err) { console.error('DynamoDB put failed', err); }

    if (isServiceSlip && completed && contractEnvIdCF) {
      const aggItem = extractServiceSlipSummaryFromTabs(tabMap, cfMap);
      await upsertSlipAgg(contractEnvIdCF, aggItem, s3Key || null);
    }

    if (!isServiceSlip) {
      if (!completed) {
        console.log('Contract not completed yet; skipping sheet append until Completed.');
      } else {
        try {
          const dayStr = (prefix = '') => {
            const val = [];
            const v = k => (tabMap[k] || '').toLowerCase();
            const P = prefix ? (s) => `SerD${prefix}-${s}` : (s) => `SerD-${s}`;
            if (onStr(v(P('M'))))   val.push('Mon');
            if (onStr(v(P('T'))))   val.push('Tue');
            if (onStr(v(P('W'))))   val.push('Wed');
            if (onStr(v(P('Thr')))) val.push('Thu');
            if (onStr(v(P('F'))))   val.push('Fri');
            if (onStr(v(P('S'))))   val.push('Sat');
            return val.join(' ');
          };

          const valuesByHeader = {
            ContractEnvelopeId: envelopeId,
            ClientName: clientNameForSave,
            ClientEmail: clientEmailForSave,
            BusinessName: tabMap.BusinessName || '',
            ServiceAddress: tabMap.ServiceAddress || '',
            BillingAddress: tabMap.BillingAddress || '',
            BillingAddress2: tabMap.BillingAddress2 || '',
            ServiceRep: 'Pending Assignment',
            Status: 'Pending Slip',
            Quantity: tabMap.Quantity || '',
            ContainerSize: tabMap.ContainerSize || '',
            ContainerID: '',
            Frequency: tabMap.Frequency || '',
            ServiceDays: dayStr(''),
            Quantity2: tabMap.Quantity2 || '',
            ContainerSize2: tabMap.ContainerSize2 || '',
            ContainerID2: '',
            Frequency2: tabMap.Frequency2 || '',
            ServiceDays2: dayStr('2'),
            Quantity3: tabMap.Quantity3 || '',
            ContainerSize3: tabMap.ContainerSize3 || '',
            ContainerID3: '',
            Frequency3: tabMap.Frequency3 || '',
            ServiceDays3: dayStr('3'),
            ARNumber: tabMap.ARCode || tabMap.ARNumber || '',
            ContractType: (cfMap.ContractType || '').toString(),
            ContactName: tabMap.ContactName || '',
            ServicePhone: tabMap.ServicePhone || '',
            ServiceChargePerMonth: tabMap.ServiceChargePerMonth || '',
            LandfillCharge: tabMap.LandfillCharge || '',
            ExtraPickUpCharge: tabMap.ExtraPickUpCharge || '',
            FuelSurcharge: tabMap.FuelSurcharge || '',
            DeliveryFee: tabMap.DeliveryFee || '',
            BillingApprovalName: tabMap.BillingApprovalName || '',
            BillingApprovalEmail: tabMap.BillingApprovalEmail || '',
            AssignedTo: '',
            DriverEmail: '',
            DeliveryDriverName: '',
            DeliveryDriverEmail: '',
            ClaimedAt: '',
            CompletedAt: '',
            DocS3Key: s3Key || '',
            CreatedAt: now,
            SlipLink: s3Url || ''
          };

          contractRowValues = valuesByHeader;
          await ensureContainerIdsForValues(valuesByHeader, {
            contractType: valuesByHeader.ContractType || '',
            arCode: valuesByHeader.ARNumber || ''
          });
          const res = await appendRowByHeaders(valuesByHeader, SHEET_NAME);
          console.log('Appended row to Google Sheet for envelope', envelopeId, 'row', res.rowIndex);
        } catch (gsErr) { console.error('Failed to append to Google Sheet:', gsErr); }
      }
    }

    // SNS for contract completion
    try {
      if (!isServiceSlip && SNS_ARN && completed) {
        const quantitySummary = [contractRowValues?.Quantity, contractRowValues?.Quantity2, contractRowValues?.Quantity3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const frequencySummary = [contractRowValues?.Frequency, contractRowValues?.Frequency2, contractRowValues?.Frequency3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const scheduledPickupSummary = [contractRowValues?.ServiceDays, contractRowValues?.ServiceDays2, contractRowValues?.ServiceDays3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const snsMessage = buildContractSnsMessage({
          clientName: clientNameForSave,
          businessName: tabMap.BusinessName || '',
          serviceAddress: tabMap.ServiceAddress || '',
          arNumber: contractRowValues?.ARNumber || arCodeForSave || '',
          contractType: contractRowValues?.ContractType || (cfMap.ContractType || ''),
          quantity: quantitySummary || (contractRowValues?.Quantity ? String(contractRowValues.Quantity).trim() : ''),
          frequency: frequencySummary || (contractRowValues?.Frequency ? String(contractRowValues.Frequency).trim() : ''),
          scheduledPickupDays: scheduledPickupSummary || (contractRowValues?.ServiceDays ? String(contractRowValues.ServiceDays).trim() : ''),
          dateSigned: tabMap.ContartStartDate || tabMap.ContractStartDate || '',
          containerIds: listContainerIdsFromTarget(contractRowValues),
          envelopeId
        });
        await sns.publish({ TopicArn: SNS_ARN, Message: snsMessage, Subject: 'Contract Completed' }).promise();
        console.log('Published SNS message');
      }
    } catch (snsErr) { console.error('SNS publish failed', snsErr); }

    // ===== Service Slip: archive + Welcome =====
    if (isServiceSlip && completed) {
      const isFinalInBatch = (slipBatchTotal <= 1) || (slipBatchIndex === slipBatchTotal);

      // Read aggregation and re-read once after upsert (mitigates one-race on first slip)
      let agg = await getSlipAgg(contractEnvIdCF);
      if (agg.items.length < 1 || agg.expected === 0) {
        await new Promise(r => setTimeout(r, 150)); // tiny backoff
        agg = await getSlipAgg(contractEnvIdCF);
      }
      const allCompleted = !REQUIRE_ALL_SLIPS_BEFORE_WELCOME || (agg.expected > 0 && (agg.items || []).length >= agg.expected);
      const notSentYet = !agg.welcomeSent;

      // FIX: log the welcome gating decision so its obvious in logs
      console.log('Welcome gate', {
        isFinalInBatch, expected: agg.expected, haveItems: (agg.items || []).length, notSentYet
      });

      if (isFinalInBatch && allCompleted && notSentYet) {
        let sheetItems = await readContractItemsFromSheet(contractEnvIdCF);
        if (!sheetItems || sheetItems.length === 0) {
          sheetItems = [ extractServiceSlipSummaryFromTabs(tabMap, cfMap) ];
        }
        // Ensure current slip's ID participates
        const thisSlip = extractServiceSlipSummaryFromTabs(tabMap, cfMap);
        const emailAggItems = Array.isArray(agg.items) ? [...agg.items] : [];
        if (thisSlip && thisSlip.containerId) emailAggItems.push(thisSlip);

        const itemsForEmail = expandItemsWithIds(sheetItems, emailAggItems);
        console.log('Welcome payload items:', {
          sheetItems: sheetItems.length,
          aggItems: (agg.items || []).length,
          finalItems: itemsForEmail.length,
          ids: (agg.items || []).map(x => x && x.containerId).filter(Boolean)
        });

        try {
          const ok = await archiveCompletedRowByContract(
            contractEnvIdCF,
            {
              DocS3Key: s3Key || null,
              SlipLink: s3Url || null,
              ContactName: tabMap.ContactName || '',
              ServicePhone: tabMap.ServicePhone || ''
            }
          );
          if (!ok) console.log('Archive row: nothing to do (row not found).');
        } catch (e) { console.error('Archive row failed:', e?.message || e); }

        let documents = [];
        if (WELCOME_ATTACHMENTS) {
          let contractDoc = null;
          try {
            const getRes = await ddb.get({ TableName: TABLE, Key: { ContractEnvelopeId: contractEnvIdCF } }).promise();
            const k = getRes?.Item?.DocS3Key;
            if (k) contractDoc = { type: 'contract', s3Bucket: BUCKET, s3Key: k, filename: 'Service Agreement.pdf' };
          } catch (e) { console.warn('DDB get for contract failed:', e?.message || e); }

          const slipKeys = dedupeKeepOrder([...(agg.keys || []), s3Key].filter(Boolean));
          slipKeys.forEach((k, i) => {
            documents.push({
              type: 'serviceSlip',
              s3Bucket: BUCKET,
              s3Key: k,
              filename: slipKeys.length > 1 ? `Service Slip ${i+1}.pdf` : 'Service Slip.pdf'
            });
          });
          if (contractDoc) documents.push(contractDoc);
          console.log('Welcome attachments (enabled)', { slipCount: (slipKeys || []).length, hasContract: !!contractDoc });
        } else {
          console.log('Welcome attachments disabled by config');
        }

        if (WELCOME_LAMBDA_ARN) {
          try {
            const payloadToWelcome = {
              event: 'service-slip-completed',
              envelopeId,
              clientEmail: clientEmailForSave || '',
              clientName: clientNameForSave || '',
              businessName: tabMap.BusinessName || '',
              items: itemsForEmail,
              documents,
              ccList: WELCOME_CC ? WELCOME_CC.split(',').map(s => s.trim()).filter(Boolean) : []
            };

            // Idempotency: set WelcomeSent only once
            let canSend = true;
            try {
              await ddb.update({
                TableName: TABLE,
                Key: { ContractEnvelopeId: contractEnvIdCF },
                UpdateExpression: 'SET WelcomeSent = :t',
                ConditionExpression: 'attribute_not_exists(WelcomeSent)',
                ExpressionAttributeValues: { ':t': true }
              }).promise();
            } catch (e) {
              if ((e?.code || e?.name) === 'ConditionalCheckFailedException') {
                canSend = false;
                console.log('Welcome already sent; skipping invoke');
              } else {
                console.warn('WelcomeSent flag update failed; proceeding', e?.message || e);
              }
            }

            if (canSend) {
              await lambdaClient.invoke({
                FunctionName: WELCOME_LAMBDA_ARN,
                InvocationType: 'Event',
                Payload: JSON.stringify(payloadToWelcome)
              }).promise();
              console.log('Invoked Welcome Email Lambda (final, all slips complete)', envelopeId);
            }
          } catch (invErr) { console.error('Welcome Email Lambda invoke failed', invErr); }
        }

        // Staff summary to SNS (built from the Google Sheet row)
        try {
          if (SNS_ARN) {
            const row = await getSheetRowMapByContract(contractEnvIdCF);
            const scheduledDaysParts = [row?.ServiceDays, row?.ServiceDays2, row?.ServiceDays3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const scheduledPickupDays = scheduledDaysParts.length > 0
              ? scheduledDaysParts.join(' | ')
              : (row?.ServiceDays ? String(row.ServiceDays).trim() : '');
            const quantityParts = [row?.Quantity, row?.Quantity2, row?.Quantity3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const frequencyParts = [row?.Frequency, row?.Frequency2, row?.Frequency3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const containerIdsFromRow = listContainerIdsFromTarget(row);

            const snsMessage = buildContractSnsMessage({
              clientName: row?.ClientName || clientNameForSave || '',
              businessName: row?.BusinessName || '',
              serviceAddress: row?.ServiceAddress || '',
              arNumber: row?.ARNumber || '',
              contractType: row?.ContractType || '',
              quantity: quantityParts.join(' | '),
              frequency: frequencyParts.join(' | '),
              scheduledPickupDays,
              dateSigned: row?.ContartStartDate || row?.ContractStartDate || row?.CreatedAt || '',
              containerIds: containerIdsFromRow,
              envelopeId
            });

            await sns.publish({ TopicArn: SNS_ARN, Subject: 'Service Slip Completed - Verify Trux', Message: snsMessage }).promise();
            console.log('Published SNS staff summary');
          }
        } catch (e) { console.error('SNS staff summary failed', e); }
      } else {
        console.log(`Service slip completed (${slipBatchIndex}/${slipBatchTotal})  final-gate not met: isFinal=${isFinalInBatch}, allCompleted=${allCompleted}, notSentYet=${notSentYet}.`);
      }
    }

    return { statusCode: 200, body: 'OK' };
  } catch (err) {
    console.error('Error processing request:', err);
    return { statusCode: 500, body: 'Internal error' };
  }
};

Version 37:
// index.js - Lambda for DocuSign Connect + Apps Script /send-service-slip
'use strict';

const AWS = require('aws-sdk');
const xml2js = require('xml2js');
const { google } = require('googleapis');
const docusign = require('docusign-esign');
const crypto = require('crypto');

const s3 = new AWS.S3();
const ddb = new AWS.DynamoDB.DocumentClient();
const sns = new AWS.SNS();
const secrets = new AWS.SecretsManager();
const lambdaClient = new AWS.Lambda();
const parser = new xml2js.Parser({ explicitArray: false, trim: true });

/* ===================== ENV ===================== */
const BUCKET = process.env.S3_BUCKET;
const TABLE = process.env.DDB_TABLE;
const SHEET_ID = process.env.SHEET_ID;
const GOOGLE_SECRET_ARN = process.env.GOOGLE_SECRET_ARN;
const SNS_ARN = process.env.SNS_ARN;
const EXPECTED_API_KEY = process.env.API_KEY || '';
const SHEET_NAME = process.env.SHEET_NAME || 'ServiceSlips';

// DocuSign config
const DS_IK = (process.env.DOCUSIGN_INTEGRATION_KEY || '').trim();
const DS_USER_ID = (process.env.DOCUSIGN_USER_ID || '').trim();
const DS_ACCOUNT_ID = (process.env.DOCUSIGN_ACCOUNT_ID || '').trim();
const DS_OAUTH_BASE = ((process.env.DOCUSIGN_OAUTH_BASE_URL || 'account.docusign.com').replace(/^https?:\/\//,'')).trim();
const DS_REST_BASE = (process.env.DOCUSIGN_BASE_PATH || 'https://www.docusign.net/restapi').trim();
const DS_PRIVATE_KEY_SECRET_ARN =
  (process.env.DOCUSIGN_PRIVATE_KEY_SECRET_ARN || process.env.DOCUSIGN_JWT_SECRET_ARN || '').trim();
const DS_TEMPLATE_ID = (process.env.DOCUSIGN_TEMPLATE_ID || '').trim();

// Roles (must match Service Slip template)
const DS_SIGNER_ROLE_ENV    = (process.env.DOCUSIGN_SIGNER_ROLE    || 'SS Delivery Team').trim();
const DS_CC_ROLE_ENV        = (process.env.DOCUSIGN_CC_ROLE        || '').trim();
const DS_APPROVER_ROLE_ENV  = (process.env.DOCUSIGN_APPROVER_ROLE  || 'Staff Approver').trim();
const DS_BILLING_ROLE_ENV   = (process.env.DOCUSIGN_BILLING_ROLE   || 'BillingApproval').trim();

const COUNTER_PK_PREFIX = 'Counter#';

// Signer (driver) + CC defaults
const DEFAULT_SIGNER_EMAIL = (process.env.SERVICE_SLIP_TO_EMAIL || '').trim();
const DEFAULT_SIGNER_NAME  = (process.env.SERVICE_SLIP_TO_NAME_SS_Delivery_Team || 'SS Delivery Team').trim();
const DELIVERY_CC_EMAIL = (process.env.DELIVERY_CC_EMAIL || '').trim();
const DELIVERY_CC_NAME  = (process.env.DELIVERY_CC_NAME  || 'Dispatch Team').trim();

// Staff approver defaults (optional)
const DEFAULT_APPROVER_EMAIL = (process.env.STAFF_APPROVER_EMAIL || '').trim();
const DEFAULT_APPROVER_NAME  = (process.env.STAFF_APPROVER_NAME  || 'Staff Approver').trim();

// Welcome email hook
const SS_SUBJECT_PREFIX = (process.env.SERVICE_SLIP_SUBJECT_PREFIX || 'Service Slip: ').trim();
const WELCOME_LAMBDA_ARN = (process.env.WELCOME_LAMBDA_ARN || '').trim();
const WELCOME_CC = (process.env.WELCOME_CC || '').trim(); // comma-separated
// Behavior toggles
const STORE_CONTRACT_PDF = ['x','on','yes','true','1'].includes(String(process.env.STORE_CONTRACT_PDF ?? 'true').toLowerCase());
const WELCOME_ATTACHMENTS = ['x','on','yes','true','1'].includes(String(process.env.WELCOME_ATTACHMENTS ?? 'false').toLowerCase());
const REQUIRE_ALL_SLIPS_BEFORE_WELCOME = ['x','on','yes','true','1'].includes(String(process.env.REQUIRE_ALL_SLIPS_BEFORE_WELCOME ?? 'true').toLowerCase());

// Contract connect allow-list (contracts only)
const CONTRACT_ALLOWED_TEMPLATE_IDS = (
  process.env.CONTRACT_ALLOWED_TEMPLATE_IDS ||
  '1eda2cbe-0073-4340-9bfe-d3aac29591b7'
).split(',').map(s => s.trim().toLowerCase()).filter(Boolean);

// Role names to identify client/sales in Connect payload (contracts)
const CONTRACT_CLIENT_ROLE = (process.env.CONTRACT_CLIENT_ROLE || 'New Front Load Client').trim();
const CONTRACT_SALES_ROLE  = (process.env.CONTRACT_SALES_ROLE  || 'SS Sales Rep').trim();

/* ===================== UTIL ===================== */
const safeEq  = (a,b) => (a||'').toLowerCase() === (b||'').toLowerCase();
const nonEmpty = s => typeof s === 'string' && s.trim().length > 0;
const onStr = v => ['x','on','yes','true','1'].includes(String(v||'').toLowerCase());
const normHeader = (h) => String(h||'').trim().toLowerCase().replace(/[\s_-]+/g,'');

async function getConnectSecret() {
  if (process.env.CONNECT_HMAC_SECRET) return process.env.CONNECT_HMAC_SECRET;
  if (process.env.CONNECT_HMAC_SECRET_ARN) {
    const sec = await secrets.getSecretValue({ SecretId: process.env.CONNECT_HMAC_SECRET_ARN }).promise();
    const s = sec.SecretString || Buffer.from(sec.SecretBinary || '', 'base64').toString('utf8');
    try { return JSON.parse(s).docusign_connect_hmac || s; } catch { return s; }
  }
  return null;
}

function verifyDocusignHmac(rawBody, headerValue, secret) {
  if (!headerValue || !secret) return false;
  const expected = crypto.createHmac('sha256', Buffer.from(secret, 'utf8'))
                         .update(rawBody, 'utf8')
                         .digest('base64');
  const got = headerValue.replace(/"/g, '');
  try { return crypto.timingSafeEqual(Buffer.from(got), Buffer.from(expected)); }
  catch { return false; }
}

/* ---------- Google Sheets ---------- */
async function getGoogleJwtClient() {
  if (!GOOGLE_SECRET_ARN) throw new Error('GOOGLE_SECRET_ARN not set');
  const sec = await secrets.getSecretValue({ SecretId: GOOGLE_SECRET_ARN }).promise();
  const secretString = sec.SecretString || (sec.SecretBinary && sec.SecretBinary.toString());
  if (!secretString) throw new Error('Google secret returned empty SecretString');
  const serviceAccount = JSON.parse(secretString);
  const jwtClient = new google.auth.JWT(
    serviceAccount.client_email,
    null,
    serviceAccount.private_key,
    ['https://www.googleapis.com/auth/spreadsheets']
  );
  await jwtClient.authorize();
  return jwtClient;
}

function colNumberToLetter(n) {
  let s = '';
  while (n > 0) { const m = (n - 1) % 26; s = String.fromCharCode(65 + m) + s; n = Math.floor((n - 1) / 26); }
  return s;
}

async function appendRowByHeaders(valuesByHeader, targetSheetName = SHEET_NAME) {
  if (!SHEET_ID) throw new Error('SHEET_ID not configured');
  const jwt = await getGoogleJwtClient();
  const sheets = google.sheets({ version: 'v4', auth: jwt });

  const headerResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${targetSheetName}!1:1`
  });
  const sheetHeaders = (headerResp.data && headerResp.data.values && headerResp.data.values[0]) || [];
  const headerCount = Math.max(sheetHeaders.length, Object.keys(valuesByHeader || {}).length, 10);

  const colAResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${targetSheetName}!A:A`
  });
  const colAValues = (colAResp.data && colAResp.data.values) ? colAResp.data.values : [];
  const colAText = [];
  for (let i = 0; i < colAValues.length; i++) {
    const row = colAValues[i];
    colAText.push((row && row.length && typeof row[0] !== 'undefined') ? String(row[0]) : '');
  }
  let firstEmptyRow = null;
  for (let i = 1; i < colAText.length; i++) {
    if (colAText[i] === '' || colAText[i] === null) { firstEmptyRow = i + 1; break; }
  }
  const nextRowIndex = firstEmptyRow ? firstEmptyRow : (colAText.length === 0 ? 2 : colAText.length + 1);

  const row = new Array(headerCount).fill('');
  sheetHeaders.forEach((h, i) => {
    if (!h) return;
    const key = String(h).trim();
    if (Object.prototype.hasOwnProperty.call(valuesByHeader, key)) {
      const val = valuesByHeader[key];
      row[i] = (val === null || typeof val === 'undefined') ? '' :
               (val instanceof Date ? val.toISOString() : String(val));
    }
  });

  const endColIndex = Math.max(sheetHeaders.length, headerCount);
  const lastColLetter = colNumberToLetter(endColIndex);
  const range = `${targetSheetName}!A${nextRowIndex}:${lastColLetter}${nextRowIndex}`;

  await sheets.spreadsheets.values.update({
    spreadsheetId: SHEET_ID, range, valueInputOption: 'RAW', requestBody: { values: [row] }
  });

  console.log(`Wrote ${targetSheetName} row`, nextRowIndex);
  return { rowIndex: nextRowIndex };
}

/* ======= Sheet helper for archiving a completed slip (handles duplicates) ======= */
async function archiveCompletedRowByContract(contractEnvId, extraUpdates = {}) {
  if (!contractEnvId) return false;

  const jwt = await getGoogleJwtClient();
  const sheets = google.sheets({ version: 'v4', auth: jwt });

  const meta = await sheets.spreadsheets.get({
    spreadsheetId: SHEET_ID,
    fields: 'sheets(properties(title,sheetId),protectedRanges)'
  });

  const svcSheet = (meta.data.sheets || []).find(s => s.properties.title === SHEET_NAME);
  if (!svcSheet) { console.warn('ServiceSlips sheet not found'); return false; }
  const svcId = svcSheet.properties.sheetId;

  const headersResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1`
  });
  const headers = (headersResp.data.values && headersResp.data.values[0]) || [];
  const hdrMap = {}; headers.forEach((h,i) => { if (h) hdrMap[String(h).trim()] = i; });

  const ceColIdx = hdrMap['ContractEnvelopeId'];
  if (typeof ceColIdx === 'undefined') { console.warn('ContractEnvelopeId column not found'); return false; }
  const ceLetter = colNumberToLetter(ceColIdx + 1);

  const colResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}`
  });
  const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
  const rowIndexes = [];
  for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) rowIndexes.push(i + 1); }
  if (rowIndexes.length === 0) { console.log('No matching row in sheet for CEID', contractEnvId); return false; }

  const firstRow = rowIndexes[0];
  const rowResp = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${firstRow}:${firstRow}`
  });
  let values = (rowResp.data.values && rowResp.data.values[0]) || [];

  const apply = (name, val) => { if (typeof hdrMap[name] !== 'undefined') { values[hdrMap[name]] = val; } };
  apply('Status', 'Service Slip Completed');
  apply('UpdatedAt', new Date().toISOString());
  if (extraUpdates.DocS3Key) apply('DocS3Key', extraUpdates.DocS3Key);
  if (extraUpdates.SlipLink)  apply('SlipLink',  extraUpdates.SlipLink);
  // Apply any other provided updates (e.g., ContactName, ServicePhone)
  if (extraUpdates && typeof extraUpdates === 'object') {
    Object.entries(extraUpdates).forEach(([k, v]) => {
      if (k !== 'DocS3Key' && k !== 'SlipLink') apply(k, v);
    });
  }

  const compSheet = (meta.data.sheets || []).find(s => s.properties.title === 'Completed');
  if (!compSheet) {
    await sheets.spreadsheets.batchUpdate({
      spreadsheetId: SHEET_ID,
      requestBody: { requests: [{ addSheet: { properties: { title: 'Completed' } } }] }
    });
    await sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `Completed!1:1`,
      valueInputOption: 'RAW',
      requestBody: { values: [headers] }
    });
  } else {
    const h = await sheets.spreadsheets.values.get({
      spreadsheetId: SHEET_ID, range: `Completed!1:1`
    });
    const got = (h.data.values && h.data.values[0]) || [];
    if (got.length === 0) {
      await sheets.spreadsheets.values.update({
        spreadsheetId: SHEET_ID,
        range: `Completed!1:1`,
        valueInputOption: 'RAW',
        requestBody: { values: [headers] }
      });
    }
  }

  await sheets.spreadsheets.values.append({
    spreadsheetId: SHEET_ID,
    range: `Completed!A:A`,
    valueInputOption: 'RAW',
    insertDataOption: 'INSERT_ROWS',
    requestBody: { values: [values] }
  });

  async function safeDeleteRow(rowIndex) {
    try {
      await sheets.spreadsheets.batchUpdate({
        spreadsheetId: SHEET_ID,
        requestBody: {
          requests: [{
            deleteDimension: {
              range: { sheetId: svcId, dimension: 'ROWS', startIndex: rowIndex - 1, endIndex: rowIndex }
            }
          }]
        }
      });
      return true;
    } catch (delErr) {
      console.warn('Delete failed; will try removing intersecting protections & retry.', delErr?.message || delErr);
      try {
        const protInThisSheet =
          (meta.data.sheets || []).find(s => s.properties.sheetId === svcId)?.protectedRanges || [];
        const toRemove = protInThisSheet.filter(pr => {
          const r = pr.range || {};
          if (r.sheetId !== svcId) return false;
          const start = (r.startRowIndex ?? 0) + 1;
          const end   = (r.endRowIndex ?? 1e9);
          return rowIndex >= start && rowIndex <= end;
        });
        if (toRemove.length > 0) {
          await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SHEET_ID,
            requestBody: {
              requests: toRemove
                .filter(p => typeof p.protectedRangeId === 'number')
                .map(p => ({ deleteProtectedRange: { protectedRangeId: p.protectedRangeId } }))
            }
          });
          await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SHEET_ID,
            requestBody: {
              requests: [{
                deleteDimension: {
                  range: { sheetId: svcId, dimension: 'ROWS', startIndex: rowIndex - 1, endIndex: rowIndex }
                }
              }]
            }
          });
          return true;
        }
      } catch (e2) {
        console.warn('Protection removal / retry delete failed:', e2?.message || e2);
      }
      try {
        await sheets.spreadsheets.values.clear({
          spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}`
        });
        await sheets.spreadsheets.values.update({
          spreadsheetId: SHEET_ID,
          range: `${SHEET_NAME}!A${rowIndex}:A${rowIndex}`,
          valueInputOption: 'RAW',
          requestBody: { values: [[`(Archived to Completed @ ${new Date().toISOString()})`]] }
        });
        return true;
      } catch (clrErr) {
        console.error('Fallback clear failed:', clrErr);
        return false;
      }
    }
  }

  rowIndexes.sort((a,b)=>b-a);
  for (let idx = 0; idx < rowIndexes.length; idx++) {
    await safeDeleteRow(rowIndexes[idx]);
  }

  console.log('Archived & removed', rowIndexes.length, 'row(s) for CEID', contractEnvId);
  return true;
}

/* ---------- S3 (named save) ---------- */
function sanitizeForS3(s) {
  return String(s || '')
    .replace(/[^\w\- .]/g, '')
    .replace(/\s+/g,' ')
    .trim();
}
async function savePdfToS3Named({ type, envelopeId, pdfBase64, arCode, clientName }) {
  if (!BUCKET) throw new Error('S3_BUCKET not configured');
  const buffer = Buffer.from(pdfBase64, 'base64');

  const prettyClient = sanitizeForS3(clientName || 'Unknown Customer');
  const prettyAR     = sanitizeForS3(arCode || '');
  const folder = prettyAR ? `${prettyAR} - ${prettyClient}` : `No-AR - ${prettyClient}`;
  const fname  = `${type || 'Document'}-${envelopeId}-${Date.now()}.pdf`;
  const key    = `contracts/${folder}/${sanitizeForS3(fname)}`;

  await s3.putObject({ Bucket: BUCKET, Key: key, Body: buffer, ContentType: 'application/pdf' }).promise();
  const signedUrl = s3.getSignedUrl
    ? s3.getSignedUrl('getObject', { Bucket: BUCKET, Key: key, Expires: 60 * 60 * 24 * 7 })
    : `s3://${BUCKET}/${key}`;
  return { key, signedUrl };
}

/* ---------- API-key gate ---------- */
function checkApiKey(headers) {
  const incomingKey = (headers && (headers['x-api-key'] || headers['X-API-Key'] || headers['X-API-KEY'])) || '';
  if (!incomingKey) return false;
  if (!EXPECTED_API_KEY) { console.warn('No EXPECTED_API_KEY set in Lambda env; rejecting by default'); return false; }
  return incomingKey === EXPECTED_API_KEY;
}

function deriveContractTypeCode(raw) {
  const val = (raw || '').toString().toLowerCase();
  if (val.includes('roll')) return 'RO';
  if (val.includes('ro-')) return 'RO';
  if (val.includes('ro ')) return 'RO';
  if (val.includes('front') || val.includes('fl-') || val.includes('fl ')) return 'FL';
  return val.startsWith('ro') ? 'RO' : 'FL';
}

function normalizeContainerSizeCode(raw) {
  const text = (raw || '').toString().toLowerCase();
  const match = text.match(/(\d{1,3})/);
  if (!match) return '00';
  const num = parseInt(match[1], 10);
  if (!Number.isFinite(num) || num <= 0) return '00';
  return num < 10 ? `0${num}` : String(num);
}

function sanitizeArCode(ar) {
  const cleaned = (ar || '').toString().replace(/[^0-9a-z]/gi, '');
  return cleaned || 'NA';
}

async function nextContainerCounter(prefix, sizeCode) {
  if (!TABLE) throw new Error('DDB_TABLE not configured for container counters');
  const pk = `${COUNTER_PK_PREFIX}${prefix}-${sizeCode}`;
  const res = await ddb.update({
    TableName: TABLE,
    Key: { ContractEnvelopeId: pk },
    UpdateExpression: 'ADD CounterValue :inc',
    ExpressionAttributeValues: { ':inc': 1 },
    ReturnValues: 'UPDATED_NEW'
  }).promise();
  const val = Number(res?.Attributes?.CounterValue || 0);
  if (!Number.isFinite(val) || val <= 0) return 1;
  return val;
}

async function generateContainerId(contractType, containerSize, arCode) {
  const prefix = deriveContractTypeCode(contractType);
  const sizeCode = normalizeContainerSizeCode(containerSize);
  const counterVal = await nextContainerCounter(prefix, sizeCode);
  const counterCode = String(counterVal).padStart(2, '0');
  const arClean = sanitizeArCode(arCode);
  return `${prefix}-${sizeCode}-${counterCode}-${arClean}`;
}

async function ensureContainerIdsForValues(target, context = {}) {
  const result = {};
  if (!target || typeof target !== 'object') return result;
  const contractType = context.contractType || target.ContractType || target.contractType || '';
  const arCode = context.arCode || target.ARNumber || target.ARCode || '';
  const pairs = [
    { sizeKey: 'ContainerSize', idKey: 'ContainerID', qtyKey: 'Quantity', defaultQty: 1 },
    { sizeKey: 'ContainerSize2', idKey: 'ContainerID2', qtyKey: 'Quantity2', defaultQty: 0 },
    { sizeKey: 'ContainerSize3', idKey: 'ContainerID3', qtyKey: 'Quantity3', defaultQty: 0 }
  ];

  for (const { sizeKey, idKey, qtyKey, defaultQty } of pairs) {
    const sizeVal = target[sizeKey] || context[sizeKey];
    const desiredQty = normalizeQty(target[qtyKey], defaultQty);
    const existingList = parseContainerIdList(target[idKey]);
    const needed = Math.max(desiredQty, existingList.length, sizeVal ? 1 : 0);

    if (!needed) {
      if (existingList.length > 0) {
        const joinedExisting = existingList.join('\n');
        target[idKey] = joinedExisting;
        result[idKey] = joinedExisting;
      }
      continue;
    }

    const ids = existingList.slice(0, needed);
    while (ids.length < needed) {
      if (!sizeVal) {
        console.warn('Skipping container id generation - missing size for', sizeKey);
        break;
      }
      try {
        const generated = await generateContainerId(contractType, sizeVal, arCode);
        ids.push(generated);
      } catch (err) {
        console.warn('generateContainerId failed', { sizeKey, sizeVal, message: err?.message || err });
        break;
      }
    }

    if (ids.length > 0) {
      const joined = ids.join('\n');
      target[idKey] = joined;
      result[idKey] = joined;
    }
  }
  return result;
}

function listContainerIdsFromTarget(target) {
  const out = [];
  if (!target || typeof target !== 'object') return out;
  ['ContainerID', 'ContainerID2', 'ContainerID3'].forEach((key) => {
    out.push(...parseContainerIdList(target[key]));
  });
  return out.filter(Boolean);
}

function parseContainerIdList(value) {
  if (!value) return [];
  if (Array.isArray(value)) {
    return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
  }
  return (value || '')
    .toString()
    .split(/[\n,;]+/)
    .map(s => s.trim())
    .filter(Boolean);
}

function formatBoldLine(label, value) {
  const val = (value ?? '').toString().trim() || '-';
  return `**${label}:** ${val}`;
}

function buildContractSnsMessage(info) {
  if (!info) return '';
  const lines = [
    formatBoldLine('ClientName', info.clientName),
    formatBoldLine('BusinessName', info.businessName),
    formatBoldLine('ServiceAddress', info.serviceAddress),
    formatBoldLine('ARNumber', info.arNumber),
    formatBoldLine('ContractType', info.contractType),
    formatBoldLine('Quantity', info.quantity),
    formatBoldLine('Frequency', info.frequency),
    formatBoldLine('ScheduledPickupDays', info.scheduledPickupDays),
    formatBoldLine('DateSigned', info.dateSigned)
  ];
  if (info.containerId) lines.push(formatBoldLine('ContainerID', info.containerId));
  if (info.envelopeId) lines.push(formatBoldLine('EnvelopeId', info.envelopeId));
  return lines.join('\n');
}
/* ===================== DocuSign helpers ===================== */
async function getDsPrivateKeyPem() {
  if (!DS_PRIVATE_KEY_SECRET_ARN) throw new Error('DOCUSIGN_PRIVATE_KEY_SECRET_ARN not set');
  const sec = await secrets.getSecretValue({ SecretId: DS_PRIVATE_KEY_SECRET_ARN }).promise();
  const secretString = sec.SecretString || (sec.SecretBinary && sec.SecretBinary.toString());
  if (!secretString) throw new Error('DocuSign private key secret empty');
  let possible = secretString;
  try { const obj = JSON.parse(secretString); possible = obj.private_key || obj.privateKey || obj.privateKeyPem || secretString; } catch {}
  return possible;
}

async function getDsApiClient() {
  if (!DS_IK || !DS_USER_ID || !DS_ACCOUNT_ID || !DS_TEMPLATE_ID) {
    throw new Error('Missing DOCUSIGN_* env vars (INTEGRATION_KEY, USER_ID, ACCOUNT_ID, TEMPLATE_ID).');
  }
  const dsClient = new docusign.ApiClient();
  dsClient.setBasePath(DS_REST_BASE);
  dsClient.setOAuthBasePath(DS_OAUTH_BASE);

  const privateKeyPem = await getDsPrivateKeyPem();
  const results = await dsClient.requestJWTUserToken(
    DS_IK, DS_USER_ID, ['signature', 'impersonation'], Buffer.from(privateKeyPem), 3600
  );
  const accessToken = results.body.access_token;
  dsClient.addDefaultHeader('Authorization', 'Bearer ' + accessToken);

  try {
    const ui = await dsClient.getUserInfo(accessToken);
    const acct = ui?.accounts?.find(a => a.accountId === DS_ACCOUNT_ID) || ui?.accounts?.[0];
    if (acct?.baseUri) {
      const resolved = acct.baseUri.endsWith('/restapi') ? acct.baseUri : `${acct.baseUri}/restapi`;
      dsClient.setBasePath(resolved);
      console.log('DocuSign resolved base path from userInfo:', resolved);
    } else {
      console.warn('userInfo returned no accounts/baseUri; using DOCUSIGN_BASE_PATH as-is.');
    }
  } catch (e) {
    console.warn('getUserInfo failed; using DOCUSIGN_BASE_PATH as-is.', e?.message || e);
  }
  return dsClient;
}

/* ---------- Core sender: one Service Slip ---------- */
async function sendServiceSlipWithTemplate(payload) {
  if (!DS_TEMPLATE_ID) throw new Error('DOCUSIGN_TEMPLATE_ID not configured');

  const signerEmail = (payload.DeliveryDriverEmail || payload.DriverEmail || payload.DeliveryEmail || DEFAULT_SIGNER_EMAIL || '').trim();
  const signerName  = (payload.DeliveryDriverName  || payload.AssignedTo  || payload.DeliveryName  || DEFAULT_SIGNER_NAME  || '').trim();
  const slipContainerId = (payload.ContainerID || payload.ContainerNumber || payload.ContainerId || '').toString().trim();
  if (!signerEmail) throw new Error('Driver email not provided (DeliveryDriverEmail/DriverEmail) and SERVICE_SLIP_TO_EMAIL not set');

  const dsClient = await getDsApiClient();
  const envelopesApi = new docusign.EnvelopesApi(dsClient);

  // Work out role names (best effort)
  try {
    const templatesApi = new docusign.TemplatesApi(dsClient);
    const rec = await templatesApi.listRecipients(DS_ACCOUNT_ID, DS_TEMPLATE_ID);
    const signerRoles = (rec.signers || []).map(s => (s.roleName || '').trim()).filter(nonEmpty);
    const ccRoles     = (rec.carbonCopies || []).map(c => (c.roleName || '').trim()).filter(nonEmpty);
    if (signerRoles.length) {
      if (!signerRoles.some(r => safeEq(r, DS_SIGNER_ROLE_ENV))) {
        console.log('Signer role names on template:', signerRoles);
      }
    }
    if (ccRoles.length && DS_CC_ROLE_ENV && !ccRoles.some(r => safeEq(r, DS_CC_ROLE_ENV))) {
      console.log('CC role names on template:', ccRoles);
    }
  } catch (e) {
    const http = e?.response;
    console.warn('listRecipients failed; proceeding with env role names', {
      status: http?.status, data: http?.data, trace: http?.headers?.['x-docusign-tracetoken']
    });
  }

  // Build tabs for the slip
  const textTabs = [];
  if (payload.ARNumber)        textTabs.push({ tabLabel: 'ARCode', value: String(payload.ARNumber) });
  if (payload.ClientName)      textTabs.push({ tabLabel: 'ClientName', value: String(payload.ClientName) });
  if (payload.ClientEmail)     textTabs.push({ tabLabel: 'ClientEmail', value: String(payload.ClientEmail) });
  if (payload.BusinessName)    textTabs.push({ tabLabel: 'BusinessName', value: String(payload.BusinessName) });
  if (payload.ServiceAddress)  textTabs.push({ tabLabel: 'ServiceAddress', value: String(payload.ServiceAddress) });
  if (payload.BillingAddress)  textTabs.push({ tabLabel: 'BillingAddress', value: String(payload.BillingAddress) });
  if (payload.BillingAddress2) textTabs.push({ tabLabel: 'BillingAddress2', value: String(payload.BillingAddress2) });
  // ContractType visible field on the slip (if present)
  const _ctVal = (function(){
    const ct = (payload.ContractType || '').toString().trim();
    if (ct) return ct;
    const size = (payload.ContainerSize || '').toString().toLowerCase();
    if (/(^|\b)(15yd|20yd|30yd|40yd)(\b|$)/.test(size)) return 'RollOff';
    return 'FrontLoad';
  })();
  ;['ContractType','ClientType','Client Type'].forEach(lbl => textTabs.push({ tabLabel: lbl, value: _ctVal }));
  // Optional contact details for driver assistance
  if (payload.ContactName)     textTabs.push({ tabLabel: 'ContactName', value: String(payload.ContactName) });
  if (payload.ServicePhone)    textTabs.push({ tabLabel: 'ServicePhone', value: String(payload.ServicePhone) });

  const cid = payload.ContainerNumber || payload.ContainerID || payload.ContainerId;
  if (cid) ['ContainerNumber','Container ID #','Container ID','ContainerID'].forEach(lbl =>
    textTabs.push({ tabLabel: lbl, value: String(cid) })
  );

  if (payload.Quantity)      textTabs.push({ tabLabel: 'Quantity', value: String(payload.Quantity) });
  if (payload.ContainerSize) textTabs.push({ tabLabel: 'ContainerSize', value: String(payload.ContainerSize) });
  if (payload.Frequency)     textTabs.push({ tabLabel: 'Frequency', value: String(payload.Frequency) });
  if (payload.ServiceDays)   textTabs.push({ tabLabel: 'ServiceDays', value: String(payload.ServiceDays) });
  if (payload.Notes)         textTabs.push({ tabLabel: 'Notes', value: String(payload.Notes) });
  if (payload.Notes2)        textTabs.push({ tabLabel: 'Notes2', value: String(payload.Notes2) });

  const today = new Date();
  const pad2 = (n) => (n < 10 ? '0' + n : '' + n);
  const mmddyyyy = `${pad2(today.getMonth() + 1)}/${pad2(today.getDate())}/${today.getFullYear()}`;
  const dateTabs = [{ tabLabel: 'Date', value: mmddyyyy }];
  const checkboxTabs = [{ tabLabel: 'Start', selected: 'true' }];

  const sizeIn = (payload.ContainerSize || '').toString().trim().toLowerCase();
  const normSize = sizeIn.replace(/\s|-/g,'').replace(/yard|yds|yrd/g,'yd');
  // Container size checkboxes. Support both FL (210yd) and Roll-Off (1540yd)
  ['2yd','4yd','6yd','8yd','10yd','15yd','20yd','30yd','40yd'].forEach(lbl => {
    if (normSize === lbl.toLowerCase()) checkboxTabs.push({ tabLabel: lbl, selected: 'true' });
  });

  const freqStr = (payload.Frequency || '').toString().trim();
  const freqN = parseInt(freqStr, 10);
  if (!Number.isNaN(freqN) && freqN >= 1 && freqN <= 6) checkboxTabs.push({ tabLabel: `Freq${freqN}`, selected: 'true' });
  // Roll-Off special case: OnCall frequency
  if (/^on[- ]?call$/i.test(freqStr)) {
    checkboxTabs.push({ tabLabel: 'OnCall', selected: 'true' });
  }

  let days = [];
  if (Array.isArray(payload.ServiceDays)) days = payload.ServiceDays;
  else if (typeof payload.ServiceDays === 'string') days = payload.ServiceDays.split(/[,\s]+/).filter(Boolean);
  const mark = (needle, label) => {
    const has = days.map(d => d.toLowerCase()).includes(needle.toLowerCase());
    if (has) checkboxTabs.push({ tabLabel: label, selected: 'true' });
  };
  mark('mon', 'SerD-M'); mark('tue', 'SerD-T'); mark('wed', 'SerD-W');
  mark('thu', 'SerD-Thr'); mark('thur','SerD-Thr'); mark('thurs','SerD-Thr');
  mark('fri', 'SerD-F'); mark('sat', 'SerD-S');

  const tabs = docusign.Tabs.constructFromObject({ textTabs, dateTabs, checkboxTabs });

  const templateRoles = [
    docusign.TemplateRole.constructFromObject({
      roleName: DS_APPROVER_ROLE_ENV, name: (payload.StaffApproverName  || DEFAULT_APPROVER_NAME),
      email: (payload.StaffApproverEmail || DEFAULT_APPROVER_EMAIL), routingOrder: 1, tabs
    }),
    docusign.TemplateRole.constructFromObject({
      roleName: DS_SIGNER_ROLE_ENV, name: signerName || 'SS Delivery Team', email: signerEmail, routingOrder: 2, tabs
    })
  ];
  const billingApprovalEmail = (payload.BillingApprovalEmail || payload.BillingApprovalEmailAddress || '').toString().trim();
  const billingApprovalName  = (payload.BillingApprovalName || '').toString().trim();
  if (billingApprovalEmail) {
    templateRoles.push(
      docusign.TemplateRole.constructFromObject({
        roleName: DS_BILLING_ROLE_ENV,
        name: billingApprovalName || billingApprovalEmail,
        email: billingApprovalEmail,
        routingOrder: 4
      })
    );
  }
  if (DELIVERY_CC_EMAIL && DS_CC_ROLE_ENV) {
    templateRoles.push(
      docusign.TemplateRole.constructFromObject({
        roleName: DS_CC_ROLE_ENV, name: DELIVERY_CC_NAME || 'Dispatch Team', email: DELIVERY_CC_EMAIL
      })
    );
  }

  const envDef = new docusign.EnvelopeDefinition();
  envDef.templateId = DS_TEMPLATE_ID;
  envDef.templateRoles = templateRoles;

  const numbering = (payload.SlipBatchTotal && payload.SlipBatchTotal > 1)
    ? ` [${payload.SlipBatchIndex}/${payload.SlipBatchTotal}]` : '';
  envDef.emailSubject = `${SS_SUBJECT_PREFIX}${payload.ClientName || payload.BusinessName || ''}${numbering}`.trim();
  envDef.customFields = docusign.CustomFields.constructFromObject({
    textCustomFields: [
      { name: 'EnvelopeType', value: 'ServiceSlip', show: 'true' },
      { name: 'ClientEmail',  value: (payload.ClientEmail || '') },
      { name: 'ClientName',   value: (payload.ClientName  || payload.BusinessName || '') },
      { name: 'ContractEnvelopeId', value: (payload.ContractEnvelopeId || '') },
      // Ensure ContractType is always populated because some templates mark it required
      { name: 'ContractType', value: (function(){
          const ct = (payload.ContractType || '').toString().trim();
          if (ct) return ct;
          const size = (payload.ContainerSize || '').toString().toLowerCase();
          if (/(^|\b)(15yd|20yd|30yd|40yd)(\b|$)/.test(size)) return 'RollOff';
          return 'FrontLoad';
        })() },
      { name: 'SlipBatchId',     value: (payload.SlipBatchId || '') },
      { name: 'SlipBatchIndex',  value: String(payload.SlipBatchIndex || 1) },
      { name: 'SlipBatchTotal',  value: String(payload.SlipBatchTotal || 1) },
      { name: 'ServiceSlipContainerId', value: slipContainerId || '' }
    ]
  });

  envDef.status = 'sent';
  // Use the single envelopesApi created above (no re-declaration)
  const result = await envelopesApi.createEnvelope(DS_ACCOUNT_ID, { envelopeDefinition: envDef });
  return { envelopeId: result.envelopeId };
}

/* ---------- Multi-line / Multi-quantity expansion ---------- */
function normalizeQty(v, def = 1) {
  const n = parseInt((v ?? '').toString(), 10);
  return Number.isFinite(n) && n > 0 ? n : def;
}
function normStr(v) { return (v ?? '').toString().trim(); }

function expandServiceSlipRequests(base) {
  const lines = [
    {
      qty: normalizeQty(base.Quantity, 1),
      size: normStr(base.ContainerSize),
      freq: normStr(base.Frequency),
      days: normStr(base.ServiceDays),
      ids: parseContainerIdList(base.ContainerID || base.ContainerNumber),
      id: normStr(base.ContainerID || base.ContainerNumber)
    },
    {
      qty: normalizeQty(base.Quantity2, 0),
      size: normStr(base.ContainerSize2),
      freq: normStr(base.Frequency2),
      days: normStr(base.ServiceDays2),
      ids: parseContainerIdList(base.ContainerID2),
      id: normStr(base.ContainerID2)
    },
    {
      qty: normalizeQty(base.Quantity3, 0),
      size: normStr(base.ContainerSize3),
      freq: normStr(base.Frequency3),
      days: normStr(base.ServiceDays3),
      ids: parseContainerIdList(base.ContainerID3),
      id: normStr(base.ContainerID3)
    }
  ];

  const slips = [];
  lines.forEach((ln, idx) => {
    const lineHasData = ln.size || ln.freq || ln.days || ln.id || (ln.ids && ln.ids.length);
    if (!lineHasData && idx > 0) return;
    const qty = ln.qty || (idx === 0 ? 1 : 0);
    if (qty <= 0) return;
    for (let i = 0; i < qty; i++) {
      const p = { ...base };
      p.ContainerSize = ln.size || base.ContainerSize;
      p.Frequency     = ln.freq || base.Frequency;
      p.ServiceDays   = ln.days || base.ServiceDays;
      const idList = ln.ids || [];
      const cid = idList[i] || idList[0] || ln.id;
      if (cid) {
        p.ContainerID = cid;
        p.ContainerNumber = cid;
      }
      slips.push(p);
    }
  });
  return slips;
}

/* ---- Helpers to extract info from Connect ---- */
function extractServiceSlipSummaryFromTabs(tabMap, cfMap = {}) {
  const sizeLabels = ['2yd','4yd','6yd','8yd','10yd'];
  const containerSize = sizeLabels.find(lbl => onStr(tabMap[lbl])) || '';

  let frequency = '';
  for (let i = 1; i <= 6; i++) if (onStr(tabMap[`Freq${i}`])) { frequency = i; break; }

  const days = [];
  if (onStr(tabMap['SerD-M']))   days.push('Mon');
  if (onStr(tabMap['SerD-T']))   days.push('Tue');
  if (onStr(tabMap['SerD-W']))   days.push('Wed');
  if (onStr(tabMap['SerD-Thr'])) days.push('Thu');
  if (onStr(tabMap['SerD-F']))   days.push('Fri');
  if (onStr(tabMap['SerD-S']))   days.push('Sat');

  const containerId =
    tabMap.ContainerID || tabMap['Container ID #'] || tabMap['Container ID'] || tabMap['ContainerID'] || cfMap.ServiceSlipContainerId || '';

  return {
    containerSize,
    frequency: frequency === '' ? '' : Number(frequency),
    serviceDays: days.join(' '),
    containerId
  };
}

/* ---- NEW: aggregate helpers to collect multi-slip info at the contract item ---- */
async function upsertSlipAgg(contractEnvId, aggItem, s3Key) {
  if (!contractEnvId) return;
  const params = {
    TableName: TABLE,
    Key: { ContractEnvelopeId: contractEnvId },
    UpdateExpression:
      'SET AggSlipItems = list_append(if_not_exists(AggSlipItems, :empty), :one),' +
      '    AggSlipS3Keys = list_append(if_not_exists(AggSlipS3Keys, :empty), :k)',
    ExpressionAttributeValues: {
      ':empty': [],
      ':one': [aggItem || {}],
      ':k': s3Key ? [s3Key] : []
    },
    ReturnValues: 'NONE'
  };
  try { await ddb.update(params).promise(); }
  catch (e) { console.warn('upsertSlipAgg failed', e?.message || e); }
}

async function getSlipAgg(contractEnvId) {
  if (!contractEnvId) return { items: [], keys: [] };
  try {
    const r = await ddb.get({ TableName: TABLE, Key: { ContractEnvelopeId: contractEnvId }, ConsistentRead: true }).promise();
    const items = Array.isArray(r?.Item?.AggSlipItems) ? r.Item.AggSlipItems : [];
    const keys  = Array.isArray(r?.Item?.AggSlipS3Keys) ? r.Item.AggSlipS3Keys : [];
    const expected = Number.isFinite(+r?.Item?.AggExpected) ? +r.Item.AggExpected : 0;
    const welcomeSent = !!r?.Item?.WelcomeSent;
    return { items, keys, expected, welcomeSent };
  } catch (e) {
    console.warn('getSlipAgg failed', e?.message || e);
    return { items: [], keys: [], expected: 0, welcomeSent: false };
  }
}

// Read the ServiceSlips sheet row for a contract and return header->value map
async function getSheetRowMapByContract(contractEnvId) {
  try {
    if (!contractEnvId || !SHEET_ID) return null;
    const jwt = await getGoogleJwtClient();
    const sheets = google.sheets({ version: 'v4', auth: jwt });
    const headersResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1` });
    const headers = (headersResp.data.values && headersResp.data.values[0]) || [];
    const hdrMap = {}; headers.forEach((h,i)=>{ if (h) hdrMap[String(h).trim()] = i; });
    const ceIdx = hdrMap['ContractEnvelopeId'];
    if (typeof ceIdx === 'undefined') return null;
    const ceLetter = colNumberToLetter(ceIdx + 1);
    const colResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}` });
    const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
    let rowIndex = -1; for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) { rowIndex = i + 1; break; } }
    if (rowIndex === -1) return null;
    const rowResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}` });
    const vals = (rowResp.data.values && rowResp.data.values[0]) || [];
    const out = {};
    headers.forEach((h,i)=>{ if (h) out[String(h).trim()] = (typeof vals[i] !== 'undefined') ? vals[i] : ''; });
    return out;
  } catch (e) {
    console.warn('getSheetRowMapByContract failed', e?.message || e);
    return null;
  }
}

async function setSlipExpected(contractEnvId, expectedCount) {
  if (!contractEnvId || !Number.isFinite(+expectedCount) || +expectedCount <= 0) return;
  const params = {
    TableName: TABLE,
    Key: { ContractEnvelopeId: contractEnvId },
    UpdateExpression: 'SET AggExpected = if_not_exists(AggExpected, :n)',
    ExpressionAttributeValues: { ':n': +expectedCount },
    ReturnValues: 'NONE'
  };
  try { await ddb.update(params).promise(); }
  catch (e) { console.warn('setSlipExpected failed', e?.message || e); }
}

function dedupeKeepOrder(arr) {
  const seen = new Set(); const out = [];
  for (const v of arr || []) { if (!v) continue; if (seen.has(v)) continue; seen.add(v); out.push(v); }
  return out;
}

/* Build final rows for email: expand quantities and assign IDs sequentially */
function expandItemsWithIds(sheetItems, aggItems) {
  const ids = (aggItems || []).map(x => x?.containerId).filter(Boolean);
  let p = 0;
  const out = [];
  (sheetItems || []).forEach(it => {
    const q = Number.isFinite(+it.quantity) ? +it.quantity : 1;
    const base = {
      containerSize: String(it.containerSize || ''),
      frequency:     it.frequency,
      serviceDays:   String(it.serviceDays || '')
    };
    for (let j = 0; j < Math.max(1, q); j++) {
      let cid = (j === 0 && it.containerId) ? String(it.containerId) : '';
      if (!cid && p < ids.length) cid = String(ids[p++]);
      out.push({ ...base, containerId: cid });
    }
  });
  return out;
}

/* ---- NEW: helpers to read recipients by role ---- */
function collectRecipientsInfo(envInfo) {
  const out = [];
  try {
    const rs = envInfo?.EnvelopeStatus?.RecipientStatuses?.RecipientStatus;
    const arr = Array.isArray(rs) ? rs : (rs ? [rs] : []);
    arr.forEach(r => {
      out.push({
        roleName: (r?.RoleName || r?.roleName || r?.RecipientType || '').toString(),
        userName: (r?.UserName || r?.userName || r?.Name || '').toString(),
        email: (r?.Email || r?.email || '').toString(),
        routingOrder: parseInt((r?.RoutingOrder || r?.routingOrder || '0').toString(), 10) || 0
      });
    });
  } catch (e) {
    console.warn('collectRecipientsInfo failed', e?.message || e);
  }
  return out;
}

async function readContractItemsFromSheet(contractEnvId) {
  try {
    const jwt = await getGoogleJwtClient();
    const sheets = google.sheets({ version: 'v4', auth: jwt });

    const headerResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!1:1` });
    const headers = (headerResp.data.values && headerResp.data.values[0]) || [];
    const hdrIndex = {}; headers.forEach((h,i)=>{ if (h) hdrIndex[normHeader(h)] = i; });

    const findCol = (name) => hdrIndex[normHeader(name)];

    const ceColIdx = findCol('ContractEnvelopeId') ?? findCol('Contract Envelope Id') ?? findCol('EnvelopeId');
    if (typeof ceColIdx === 'undefined') return [];

    const ceLetter = colNumberToLetter(ceColIdx + 1);
    const colResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${ceLetter}:${ceLetter}` });
    const col = (colResp.data.values || []).map(r => (r && r[0]) ? String(r[0]) : '');
    let rowIndex = -1; for (let i = 1; i < col.length; i++) { if (col[i] === contractEnvId) { rowIndex = i + 1; break; } }
    if (rowIndex === -1) return [];

    const rowResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!${rowIndex}:${rowIndex}` });
    const vals = (rowResp.data.values && rowResp.data.values[0]) || [];

    function at(h) { const idx = findCol(h); return typeof idx === 'number' ? (vals[idx] ?? '') : ''; }

    const lines = [
      { q: at('Quantity'),  s: at('ContainerSize'),  f: at('Frequency'),  d: at('ServiceDays'),  id: at('ContainerID') },
      { q: at('Quantity2'), s: at('ContainerSize2'), f: at('Frequency2'), d: at('ServiceDays2'), id: at('ContainerID2') },
      { q: at('Quantity3'), s: at('ContainerSize3'), f: at('Frequency3'), d: at('ServiceDays3'), id: at('ContainerID3') }
    ];

    const items = [];
    lines.forEach(l => {
      const has = (l.s || l.f || l.d || l.id);
      if (!has) return;
      const item = {
        containerSize: String(l.s || ''),
        frequency: (l.f !== '' && !isNaN(Number(l.f))) ? Number(l.f) : String(l.f || ''),
        serviceDays: String(l.d || ''),
        containerId: String(l.id || '')
      };
      const q = parseInt(String(l.q || '').trim(), 10);
      if (!isNaN(q) && q > 0) item.quantity = q;
      items.push(item);
    });

    return items;
  } catch (e) {
    console.warn('readContractItemsFromSheet failed', e?.message || e);
    return [];
  }
}

/* ---- Allow check helpers ---- */
function findTemplateIds(info) {
  const ids = new Set();
  (function walk(o) {
    if (!o || typeof o !== 'object') return;
    for (const [k, v] of Object.entries(o)) {
      if (typeof v === 'string' && /templateid/i.test(k) && v.match(/[0-9a-fA-F-]{20,}/)) ids.add(v.toLowerCase());
      if (v && typeof v === 'object') walk(v);
    }
  })(info);
  return [...ids];
}

function contractAllowedCheck(info, cfMap, recipients) {
  const templateIds = findTemplateIds(info);
  const byTemplate  = templateIds.some(id => CONTRACT_ALLOWED_TEMPLATE_IDS.includes(id));
  const envType = (cfMap.EnvelopeType || cfMap['Envelope Type'] || '').toLowerCase();
  const byEnvType   = envType === 'serviceagreements';
  const byRole      = recipients.some(r => safeEq(r.roleName, CONTRACT_CLIENT_ROLE));

  console.log('AllowCheck -> byTemplate:', byTemplate,
              'byEnvType:', byEnvType, 'byRole:', byRole,
              'templateIds:', templateIds, 'envType:', envType);

  return byTemplate || byEnvType || byRole;
}

/* ===================== Handler ===================== */
exports.handler = async (event) => {
  console.log('Event received', {
    routeKey: event.routeKey || (event.httpMethod && (event.httpMethod + ' ' + (event.rawPath || event.path))),
    path: event.rawPath || event.path
  });

  try {
    const headers = event.headers || {};
    const rawBody = event.isBase64Encoded
      ? Buffer.from((event.body || ''), 'base64').toString('utf8')
      : (event.body || '');

    const routeKey = event.routeKey || `${event.httpMethod || 'POST'} ${event.rawPath || event.path || ''}`;
    // Strict path-based detection to avoid accidental double-processing
    const isSendSlip =
      (routeKey && /\/send-service-slip\b/.test(routeKey)) ||
      (event.rawPath && /\/send-service-slip\b/.test(event.rawPath || '')) ||
      (event.path && /\/send-service-slip\b/.test(event.path || ''));

    // 1) API key for /send-service-slip
    if (isSendSlip && !checkApiKey(headers)) {
      console.warn('Unauthorized: invalid or missing API key for send-service-slip');
      return { statusCode: 401, body: JSON.stringify({ success: false, error: 'Unauthorized' }) };
    }

    // 2) HMAC for Connect webhooks
    if (!isSendSlip) {
      const sigHeader = headers['x-docusign-signature-1'] || headers['X-DocuSign-Signature-1'];
      const secret = await getConnectSecret();
      if (secret && !verifyDocusignHmac(rawBody, sigHeader, secret)) {
        console.warn('Invalid DocuSign HMAC', { hasHeader: !!sigHeader });
        return { statusCode: 401, body: 'Invalid signature' };
      }
    }

    const contentType = (headers['content-type'] || headers['Content-Type'] || '').toLowerCase();
    console.log('routeKey', routeKey, 'contentType', contentType);

    /* ----------------- Route: send-service-slip ----------------- */
    if (isSendSlip) {
      let payload;
      try { payload = typeof rawBody === 'string' && rawBody.length ? JSON.parse(rawBody) : {}; }
      catch (e) { console.error('Invalid JSON payload', e); return { statusCode: 400, body: JSON.stringify({ success: false, error: 'Invalid JSON body' }) }; }

      // 1) write row
      const valuesByHeader = Object.assign({}, payload);
      // ---------- NEW: map AR to the ARNumber column on first write ----------
      valuesByHeader.ARNumber = payload.ARNumber || payload.ARCode || '';
      if (!valuesByHeader.CreatedAt) valuesByHeader.CreatedAt = new Date().toISOString();
      if (!valuesByHeader.Status)     valuesByHeader.Status     = 'Service Slip Initiated';
      if (!valuesByHeader.ServiceRep) valuesByHeader.ServiceRep = 'Pending Assignment';
      const generatedIds = await ensureContainerIdsForValues(valuesByHeader, {
        contractType: payload.ContractType || valuesByHeader.ContractType || '',
        arCode: payload.ARNumber || payload.ARCode || valuesByHeader.ARNumber || ''
      });
      if (generatedIds && Object.keys(generatedIds).length > 0) {
        Object.assign(payload, generatedIds);
      }

      let appended;
      try { appended = await appendRowByHeaders(valuesByHeader, SHEET_NAME); }
      catch (err) {
        console.error('Failed to append from send-service-slip', err);
        return { statusCode: 500, body: JSON.stringify({ success: false, error: 'Failed to write sheet', detail: err.message }) };
      }

      // 2) Expand into N slips and send  add batch numbering
      try {
        const slips = expandServiceSlipRequests(payload);
        console.log('Prepared slips count:', slips.length, 'details:',
          slips.map((s, idx) => ({
            i: idx + 1,
            size: s.ContainerSize,
            freq: s.Frequency,
            days: s.ServiceDays,
            id: (s.ContainerID || s.ContainerNumber || s.ContainerId || '')
          }))
        );
        if (slips.length === 0) throw new Error('No slip line-items found (check Quantity/ContainerSize/Frequency/ServiceDays fields).');

        const batchId = `${payload.ContractEnvelopeId || 'no-contract'}-${Date.now()}`;
        const envelopeIds = [];

        for (let i = 0; i < slips.length; i++) {
          const one = slips[i];
          one.SlipBatchId = batchId;
          one.SlipBatchIndex = i + 1;
          one.SlipBatchTotal = slips.length;

          console.log(`Sending slip ${i+1}/${slips.length}`, {
            contract: one.ContractEnvelopeId || '(none)',
            size: one.ContainerSize, freq: one.Frequency, days: one.ServiceDays,
            id: (one.ContainerID || one.ContainerNumber || one.ContainerId || '')
          });
          const res = await sendServiceSlipWithTemplate(one);
          envelopeIds.push(res.envelopeId);
        }

        // Record the expected number of slips for this contract once per batch
        try { await setSlipExpected(payload.ContractEnvelopeId, slips.length); } catch {}

        return {
          statusCode: 200,
          body: JSON.stringify({
            success: true,
            rowIndex: appended?.rowIndex,
            newStatus: 'Service Slip Initiated',
            serviceSlipEnvelopeId: envelopeIds[0] || null,
            serviceSlipEnvelopeIds: envelopeIds,
            createdCount: envelopeIds.length
          })
        };
      } catch (dsErr) {
        const message = dsErr?.response?.data?.message || dsErr?.message || String(dsErr);
        console.error('DocuSign send failed:', message);
        return {
          statusCode: 200,
          body: JSON.stringify({
            success: true,
            rowIndex: appended?.rowIndex,
            newStatus: 'Service Slip Initiated',
            serviceSlipEnvelopeId: null,
            warning: 'Sheet updated but DocuSign send failed',
            errorDetail: message
          })
        };
      }
    }

    /* ----------------- Route: DocuSign Connect webhook ----------------- */
    let parsed = null;
    try {
      if (contentType.indexOf('xml') !== -1 || (rawBody && rawBody.trim().startsWith('<'))) {
        parsed = await parser.parseStringPromise(rawBody);
      } else {
        parsed = rawBody && rawBody.trim().length ? JSON.parse(rawBody) : {};
      }
    } catch (parseErr) {
      console.warn('XML parse failed, trying JSON fallback:', parseErr.message);
      try { parsed = rawBody && rawBody.trim().length ? JSON.parse(rawBody) : {}; }
      catch (jErr) { console.error('Both XML and JSON parse failed', jErr); return { statusCode: 400, body: 'Invalid payload format' }; }
    }

    const envInfo = (parsed && parsed.DocuSignEnvelopeInformation) ? parsed.DocuSignEnvelopeInformation : parsed;

    const recipients = collectRecipientsInfo(envInfo);

    let envelopeId = null, signerName = null, pdfBase64 = null, statusText = null;
    let isServiceSlip = false, clientEmailCF = '', clientNameCF = '', contractEnvIdCF = '';
    let slipBatchIndex = 1, slipBatchTotal = 1;
    let cfMap = {};

    try {
      if (envInfo?.EnvelopeStatus?.EnvelopeID) envelopeId = envInfo.EnvelopeStatus.EnvelopeID;
      else if (envInfo?.EnvelopeID) envelopeId = envInfo.EnvelopeID;
      else if (envInfo?.envelopeId) envelopeId = envInfo.envelopeId;
      else if (envInfo?.envelopeSummary?.envelopeId) envelopeId = envInfo.envelopeSummary.envelopeId;

      if (envInfo?.EnvelopeStatus?.UserName) signerName = envInfo.EnvelopeStatus.UserName;

      if (envInfo?.EnvelopeStatus?.Status) statusText = envInfo.EnvelopeStatus.Status;
      else if (envInfo?.status) statusText = envInfo.status;

      if (envInfo?.DocumentPDFs?.DocumentPDF) {
        const doc = envInfo.DocumentPDFs.DocumentPDF;
        pdfBase64 = Array.isArray(doc) ? doc[0].PDFBytes : doc.PDFBytes;
      }

      const cfArrays = [];
      if (envInfo?.EnvelopeStatus?.CustomFields?.CustomField) cfArrays.push(envInfo.EnvelopeStatus.CustomFields.CustomField);
      if (envInfo?.CustomFields?.CustomField) cfArrays.push(envInfo.CustomFields.CustomField);
      if (envInfo?.customFields?.textCustomFields) cfArrays.push(envInfo.customFields.textCustomFields);
      if (envInfo?.envelopeSummary?.customFields?.textCustomFields) cfArrays.push(envInfo.envelopeSummary.customFields.textCustomFields);
      const flatCF = []
        .concat(...cfArrays.map(x => Array.isArray(x) ? x : [x]))
        .filter(Boolean)
        .map(x => ({ name: (x.Name || x.name || '').toString(), value: (x.Value || x.value || '').toString() }));
      cfMap = {}; flatCF.forEach(({name, value}) => { if (name) cfMap[name] = value; });
      isServiceSlip = (cfMap.EnvelopeType || '').toLowerCase() === 'serviceslip';
      clientEmailCF = cfMap.ClientEmail || '';
      clientNameCF  = cfMap.ClientName  || '';
      contractEnvIdCF = cfMap.ContractEnvelopeId || '';
      slipBatchIndex = parseInt(cfMap.SlipBatchIndex || '1', 10) || 1;
      slipBatchTotal = parseInt(cfMap.SlipBatchTotal || '1', 10) || 1;
    } catch (err) { console.error('Failed to extract envelope info', err); }

    envelopeId = envelopeId || `env-${Date.now()}`;
    const now = new Date().toISOString();

    function pickTabs(info) {
      const out = {};
      try {
        const rs = info?.EnvelopeStatus?.RecipientStatuses?.RecipientStatus;
        const arr = Array.isArray(rs) ? rs : (rs ? [rs] : []);
        arr.forEach(r => {
          const tabs = r?.TabStatuses?.TabStatus;
          const tArr = Array.isArray(tabs) ? tabs : (tabs ? [tabs] : []);
          tArr.forEach(t => {
            const k = (t.TabLabel || '').toString().trim();
            const v = (t.TabValue || '').toString();
            if (k) out[k] = v;
          });
        });
      } catch {}
      return out;
    }
    const tabMap = pickTabs(envInfo);

    if (!isServiceSlip) {
      const allowed = contractAllowedCheck(envInfo, cfMap, recipients);
      if (!allowed) return { statusCode: 200, body: 'Ignored (not an allowed contract envelope)' };
    }

    const salesRec = recipients.find(r => safeEq(r.roleName, CONTRACT_SALES_ROLE));
    const clientRec = recipients.find(r => safeEq(r.roleName, CONTRACT_CLIENT_ROLE));
    const tabClientName  = (tabMap.ClientName || '').trim();
    const tabClientEmail = (tabMap.ClientEmail || '').trim();

    const clientNameForSave =
      (nonEmpty(tabClientName)  && !safeEq(tabClientName,  salesRec?.userName || '')) ? tabClientName  :
      (nonEmpty(clientNameCF)   && !safeEq(clientNameCF,   salesRec?.userName || '')) ? clientNameCF   :
      (clientRec?.userName || signerName || tabClientName || 'Unknown Customer');

    const clientEmailForSave =
      (nonEmpty(tabClientEmail) && !safeEq(tabClientEmail, salesRec?.email || '')) ? tabClientEmail :
      (nonEmpty(clientEmailCF)) ? clientEmailCF : (clientRec?.email || tabClientEmail || '');

    const arCodeForSave = tabMap.ARCode || tabMap.ARNumber || '';

    let s3Key = null, s3Url = null;
    try {
      if (pdfBase64 && (isServiceSlip || STORE_CONTRACT_PDF)) {
        const s3res = await savePdfToS3Named({
          type: isServiceSlip ? 'ServiceSlip' : 'Contract',
          envelopeId,
          pdfBase64,
          arCode: arCodeForSave,
          clientName: clientNameForSave
        });
        s3Key = s3res.key; s3Url = s3res.signedUrl;
        console.log('Saved PDF to S3 key', s3Key);
      } else if (pdfBase64 && !isServiceSlip) {
        console.log('Config STORE_CONTRACT_PDF=false  skipping contract PDF save');
      } else {
        console.log('No PDF found in payload');
      }
    } catch (err) { console.error('S3 putObject failed', err); }

    const completed = (statusText || '').toLowerCase() === 'completed';
    let contractRowValues = null;

    try {
      const item = {
        ContractEnvelopeId: envelopeId,
        Status: isServiceSlip ? (completed ? 'ServiceSlip Completed' : 'ServiceSlip Update') : (completed ? 'Contract Completed' : 'Contract Signed'),
        CreatedAt: now,
        DocS3Key: s3Key || null,
        SignerName: signerName || clientNameCF || null
      };
      await ddb.put({ TableName: TABLE, Item: item }).promise();
      console.log('Wrote item to DynamoDB:', item);
    } catch (err) { console.error('DynamoDB put failed', err); }

    if (isServiceSlip && completed && contractEnvIdCF) {
      const aggItem = extractServiceSlipSummaryFromTabs(tabMap, cfMap);
      await upsertSlipAgg(contractEnvIdCF, aggItem, s3Key || null);
    }

    if (!isServiceSlip) {
      if (!completed) {
        console.log('Contract not completed yet; skipping sheet append until Completed.');
      } else {
        try {
          const dayStr = (prefix = '') => {
            const val = [];
            const v = k => (tabMap[k] || '').toLowerCase();
            const P = prefix ? (s) => `SerD${prefix}-${s}` : (s) => `SerD-${s}`;
            if (onStr(v(P('M'))))   val.push('Mon');
            if (onStr(v(P('T'))))   val.push('Tue');
            if (onStr(v(P('W'))))   val.push('Wed');
            if (onStr(v(P('Thr')))) val.push('Thu');
            if (onStr(v(P('F'))))   val.push('Fri');
            if (onStr(v(P('S'))))   val.push('Sat');
            return val.join(' ');
          };

          const valuesByHeader = {
            ContractEnvelopeId: envelopeId,
            ClientName: clientNameForSave,
            ClientEmail: clientEmailForSave,
            BusinessName: tabMap.BusinessName || '',
            ServiceAddress: tabMap.ServiceAddress || '',
            BillingAddress: tabMap.BillingAddress || '',
            BillingAddress2: tabMap.BillingAddress2 || '',
            ServiceRep: 'Pending Assignment',
            Status: 'Pending Slip',
            Quantity: tabMap.Quantity || '',
            ContainerSize: tabMap.ContainerSize || '',
            ContainerID: '',
            Frequency: tabMap.Frequency || '',
            ServiceDays: dayStr(''),
            Quantity2: tabMap.Quantity2 || '',
            ContainerSize2: tabMap.ContainerSize2 || '',
            ContainerID2: '',
            Frequency2: tabMap.Frequency2 || '',
            ServiceDays2: dayStr('2'),
            Quantity3: tabMap.Quantity3 || '',
            ContainerSize3: tabMap.ContainerSize3 || '',
            ContainerID3: '',
            Frequency3: tabMap.Frequency3 || '',
            ServiceDays3: dayStr('3'),
            ARNumber: tabMap.ARCode || tabMap.ARNumber || '',
            ContractType: (cfMap.ContractType || '').toString(),
            ContactName: tabMap.ContactName || '',
            ServicePhone: tabMap.ServicePhone || '',
            ServiceChargePerMonth: tabMap.ServiceChargePerMonth || '',
            LandfillCharge: tabMap.LandfillCharge || '',
            ExtraPickUpCharge: tabMap.ExtraPickUpCharge || '',
            FuelSurcharge: tabMap.FuelSurcharge || '',
            DeliveryFee: tabMap.DeliveryFee || '',
            BillingApprovalName: tabMap.BillingApprovalName || '',
            BillingApprovalEmail: tabMap.BillingApprovalEmail || '',
            AssignedTo: '',
            DriverEmail: '',
            DeliveryDriverName: '',
            DeliveryDriverEmail: '',
            ClaimedAt: '',
            CompletedAt: '',
            DocS3Key: s3Key || '',
            CreatedAt: now,
            SlipLink: s3Url || ''
          };

          contractRowValues = valuesByHeader;
          await ensureContainerIdsForValues(valuesByHeader, {
            contractType: valuesByHeader.ContractType || '',
            arCode: valuesByHeader.ARNumber || ''
          });
          const res = await appendRowByHeaders(valuesByHeader, SHEET_NAME);
          console.log('Appended row to Google Sheet for envelope', envelopeId, 'row', res.rowIndex);
        } catch (gsErr) { console.error('Failed to append to Google Sheet:', gsErr); }
      }
    }

    try {
      if (!isServiceSlip && SNS_ARN && completed) {
        const quantitySummary = [contractRowValues?.Quantity, contractRowValues?.Quantity2, contractRowValues?.Quantity3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const frequencySummary = [contractRowValues?.Frequency, contractRowValues?.Frequency2, contractRowValues?.Frequency3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const scheduledPickupSummary = [contractRowValues?.ServiceDays, contractRowValues?.ServiceDays2, contractRowValues?.ServiceDays3]
          .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
          .filter((v) => v !== '')
          .join(' | ');
        const snsMessage = buildContractSnsMessage({
          clientName: clientNameForSave,
          businessName: tabMap.BusinessName || '',
          serviceAddress: tabMap.ServiceAddress || '',
          arNumber: contractRowValues?.ARNumber || arCodeForSave || '',
          contractType: contractRowValues?.ContractType || (cfMap.ContractType || ''),
          quantity: quantitySummary || (contractRowValues?.Quantity ? String(contractRowValues.Quantity).trim() : ''),
          frequency: frequencySummary || (contractRowValues?.Frequency ? String(contractRowValues.Frequency).trim() : ''),
          scheduledPickupDays: scheduledPickupSummary || (contractRowValues?.ServiceDays ? String(contractRowValues.ServiceDays).trim() : ''),
          dateSigned: tabMap.ContartStartDate || tabMap.ContractStartDate || '',
          containerIds: listContainerIdsFromTarget(contractRowValues),
          envelopeId
        });
        await sns.publish({ TopicArn: SNS_ARN, Message: snsMessage, Subject: 'Contract Completed' }).promise();
        console.log('Published SNS message');
      }
    } catch (snsErr) { console.error('SNS publish failed', snsErr); }
    if (isServiceSlip && completed) {
      const isFinalInBatch = (slipBatchTotal <= 1) || (slipBatchIndex === slipBatchTotal);

      // Read aggregation state and compute readiness to send welcome
      const agg = await getSlipAgg(contractEnvIdCF);
      const allCompleted = !REQUIRE_ALL_SLIPS_BEFORE_WELCOME || (agg.expected > 0 && (agg.items || []).length >= agg.expected);
      const notSentYet = !agg.welcomeSent;

      if (isFinalInBatch && allCompleted && notSentYet) {
        let sheetItems = await readContractItemsFromSheet(contractEnvIdCF);
        if (!sheetItems || sheetItems.length === 0) {
          sheetItems = [ extractServiceSlipSummaryFromTabs(tabMap, cfMap) ];
        }
        // Ensure current slip's ID is included even if the aggregator read is stale
        const thisSlip = extractServiceSlipSummaryFromTabs(tabMap, cfMap);
        const emailAggItems = Array.isArray(agg.items) ? [...agg.items] : [];
        if (thisSlip && thisSlip.containerId) emailAggItems.push(thisSlip);
        const itemsForEmail = expandItemsWithIds(sheetItems, emailAggItems);
        console.log('Welcome payload items:', {
          sheetItems: sheetItems.length,
          aggItems: (agg.items || []).length,
          finalItems: itemsForEmail.length,
          ids: (agg.items || []).map(x => x && x.containerId).filter(Boolean)
        });

        try {
          const ok = await archiveCompletedRowByContract(
            contractEnvIdCF,
            {
              DocS3Key: s3Key || null,
              SlipLink: s3Url || null,
              ContactName: tabMap.ContactName || '',
              ServicePhone: tabMap.ServicePhone || ''
            }
          );
          if (!ok) console.log('Archive row: nothing to do (row not found).');
        } catch (e) { console.error('Archive row failed:', e?.message || e); }

        let documents = [];
        if (WELCOME_ATTACHMENTS) {
          let contractDoc = null;
          try {
            const getRes = await ddb.get({ TableName: TABLE, Key: { ContractEnvelopeId: contractEnvIdCF } }).promise();
            const k = getRes?.Item?.DocS3Key;
            if (k) contractDoc = { type: 'contract', s3Bucket: BUCKET, s3Key: k, filename: 'Service Agreement.pdf' };
          } catch (e) { console.warn('DDB get for contract failed:', e?.message || e); }

          const slipKeys = dedupeKeepOrder([...(agg.keys || []), s3Key].filter(Boolean));
          slipKeys.forEach((k, i) => {
            documents.push({
              type: 'serviceSlip',
              s3Bucket: BUCKET,
              s3Key: k,
              filename: slipKeys.length > 1 ? `Service Slip ${i+1}.pdf` : 'Service Slip.pdf'
            });
          });
          if (contractDoc) documents.push(contractDoc);
          console.log('Welcome attachments (enabled)', { slipCount: (slipKeys || []).length, hasContract: !!contractDoc });
        } else {
          console.log('Welcome attachments disabled by config');
        }

        if (WELCOME_LAMBDA_ARN) {
          try {
            const payloadToWelcome = {
              event: 'service-slip-completed',
              envelopeId,
              clientEmail: clientEmailForSave || '',
              clientName: clientNameForSave || '',
              businessName: tabMap.BusinessName || '',
              items: itemsForEmail,
              documents,
              ccList: WELCOME_CC ? WELCOME_CC.split(',').map(s => s.trim()).filter(Boolean) : []
            };

            // Idempotency: set WelcomeSent only once
            let canSend = true;
            try {
              await ddb.update({
                TableName: TABLE,
                Key: { ContractEnvelopeId: contractEnvIdCF },
                UpdateExpression: 'SET WelcomeSent = :t',
                ConditionExpression: 'attribute_not_exists(WelcomeSent)',
                ExpressionAttributeValues: { ':t': true }
              }).promise();
            } catch (e) {
              if ((e?.code || e?.name) === 'ConditionalCheckFailedException') {
                canSend = false;
                console.log('Welcome already sent; skipping invoke');
              } else {
                console.warn('WelcomeSent flag update failed; proceeding', e?.message || e);
              }
            }

            if (canSend) {
              await lambdaClient.invoke({
                FunctionName: WELCOME_LAMBDA_ARN,
                InvocationType: 'Event',
                Payload: JSON.stringify(payloadToWelcome)
              }).promise();
              console.log('Invoked Welcome Email Lambda (final, all slips complete)', envelopeId);
            }
          } catch (invErr) { console.error('Welcome Email Lambda invoke failed', invErr); }
        }

        // Staff summary to SNS (built from the Google Sheet row)
        try {
          if (SNS_ARN) {
            const row = await getSheetRowMapByContract(contractEnvIdCF);
            const scheduledDaysParts = [row?.ServiceDays, row?.ServiceDays2, row?.ServiceDays3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const scheduledPickupDays = scheduledDaysParts.length > 0
              ? scheduledDaysParts.join(' | ')
              : (row?.ServiceDays ? String(row.ServiceDays).trim() : '');
            const quantityParts = [row?.Quantity, row?.Quantity2, row?.Quantity3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const frequencyParts = [row?.Frequency, row?.Frequency2, row?.Frequency3]
              .map((v) => (v === undefined || v === null ? '' : String(v).trim()))
              .filter((v) => v !== '');
            const containerIdsFromRow = listContainerIdsFromTarget(row);

            const snsMessage = buildContractSnsMessage({
              clientName: row?.ClientName || clientNameForSave || '',
              businessName: row?.BusinessName || '',
              serviceAddress: row?.ServiceAddress || '',
              arNumber: row?.ARNumber || '',
              contractType: row?.ContractType || '',
              quantity: quantityParts.join(' | '),
              frequency: frequencyParts.join(' | '),
              scheduledPickupDays,
              dateSigned: row?.ContartStartDate || row?.ContractStartDate || row?.CreatedAt || '',
              containerIds: containerIdsFromRow,
              envelopeId
            });

            await sns.publish({ TopicArn: SNS_ARN, Subject: 'Service Slip Completed - Verify Trux', Message: snsMessage }).promise();
            console.log('Published SNS staff summary');
          }
        } catch (e) { console.error('SNS staff summary failed', e); }
      } else {
        console.log(`Service slip completed (${slipBatchIndex}/${slipBatchTotal})  not final; skipping archive & welcome.`);
      }
    }

    return { statusCode: 200, body: 'OK' };
  } catch (err) {
    console.error('Error processing request:', err);
    return { statusCode: 500, body: 'Internal error' };
  }
};
